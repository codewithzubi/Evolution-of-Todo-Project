# Implementation Plan: Phase-I In-Memory Todo CLI

**Branch**: `001-phase-i-in-memory-cli` | **Date**: 2025-12-28 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-phase-i-in-memory-cli/spec.md`

**Note**: This template is filled in by the `/sp.plan` command. See `.specify/templates/commands/plan.md` for the execution workflow.

---

## Summary

Phase-I implements a command-line todo application using in-memory storage. The primary requirements are:

- Core CRUD operations: create, read, update, delete tasks
- Task completion status management: mark complete, incomplete, toggle
- Command-line interface with 8 commands: create, view, update, delete, complete, incomplete, toggle, help
- In-memory task storage with auto-incremented IDs
- Input validation and error handling

Technical approach focuses on clean separation of concerns with three distinct layers: presentation (CLI), business logic (service), and data (in-memory store). Python 3.13+ provides standard library capabilities sufficient for all requirements without external dependencies.

---

## Technical Context

**Language/Version**: Python 3.13+
**Primary Dependencies**: Python standard library only (argparse, sys, typing)
**Storage**: In-memory (no persistence, no database, no files)
**Testing**: Not applicable (implementation-only phase, tests generated later)
**Target Platform**: Command-line interface (terminal, console)
**Project Type**: Single project (CLI application)
**Performance Goals**: Command execution under 5 seconds, display up to 1000 tasks under 1 second
**Constraints**: In-memory only (data lost on application exit), single-user (no authentication), CLI only (no web or GUI)
**Scale/Scope**: Up to 1000 tasks, single user, single session runtime

---

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

### Initial Evaluation (Pre-Research)

- [x] Manual code writing forbidden: All implementation will be generated by Claude Code via `/sp.implement` command
- [x] Every feature has written specification: Complete specification exists in `spec.md` with 5 user stories, 29 functional requirements, 11 success criteria
- [x] Claude Code is only implementation authority: No manual code will be written; all code generation delegated to Claude Code
- [x] Specs refined until correct output: Specification is comprehensive with no NEEDS CLARIFICATION markers
- [x] Phases completed sequentially: This is Phase-I, follows phase order (I, II, III, IV, V)

### Additional Constitution Principles Verified

- [x] Spec-Driven Development: All work follows SDD methodology with specification before implementation
- [x] AI-Native Engineering: Implementation delegated to Claude Code, intelligence encapsulated in skills and subagents
- [x] Architecture over syntax: Plan focuses on architecture and interfaces, not implementation syntax
- [x] Intelligence over boilerplate: Design prioritizes reusable intelligence patterns (data model, validation logic, command structure)
- [x] Stateless execution: Application follows stateless principles (in-memory store managed explicitly, no implicit state)
- [x] Phase-I Constitutional Commitments: Design preserves todo data model, CLI command structure, validation rules for future phases

### Phase-I Constitutional Commitments Validated

#### Purpose and Intelligence Added
- [x] Purpose: Establish core functionality with minimal complexity, prove SDD methodology
- [x] Intelligence added: Basic todo data model (in-memory), CLI interface for CRUD, simple input validation

#### What Must Remain Reusable
- [x] Data model: Abstracted design allows migration to persistence in Phase-II
- [x] CLI command structure: Command patterns reusable across phases
- [x] Validation rules: Title validation, ID validation logic portable to future phases

#### What Must Remain Unchanged
- [x] User stories and acceptance criteria: All 5 user stories preserved
- [x] Core todo entity definition: id, title, description, completed attributes fixed
- [x] CRUD operation semantics: Create, read, update, delete behavior consistent

### Re-Check After Design (Post-Research and Design)

All constitution checks pass. Architecture design maintains clean separation of concerns, enables intelligence reuse, and preserves Phase-I requirements for evolution to Phases II-V.

---

## Project Structure

### Documentation (this feature)

```text
specs/001-phase-i-in-memory-cli/
├── spec.md              # Feature specification (/sp.specify output)
├── plan.md              # This file (/sp.plan command output)
├── research.md          # Phase 0 output (/sp.plan command)
├── data-model.md        # Phase 1 output (/sp.plan command)
├── quickstart.md        # Phase 1 output (/sp.plan command)
├── contracts/           # Phase 1 output (/sp.plan command)
│   ├── task-contract.md      # Task entity contract
│   └── command-contract.md   # Command interface contract
└── tasks.md             # Phase 2 output (/sp.tasks command - NOT created by /sp.plan)
```

### Source Code (repository root)

```text
src/
├── __init__.py
├── main.py                 # Application entry point
├── models/
│   ├── __init__.py
│   └── task.py             # Task data model
├── storage/
│   ├── __init__.py
│   └── in_memory_store.py   # In-memory storage implementation
├── services/
│   ├── __init__.py
│   └── task_service.py      # Task management business logic
├── cli/
│   ├── __init__.py
│   ├── commands.py           # Command handler implementations
│   ├── parser.py            # Command-line parser
│   └── formatter.py         # Output formatting
└── utils/
    ├── __init__.py
    └── validators.py        # Validation utilities
```

**Structure Decision**: Single project structure with clear separation of concerns. Presentation layer in `cli/`, business logic in `services/`, data access in `storage/`, data models in `models/`, shared utilities in `utils/`. This structure supports evolution to Phase-II (file persistence) by replacing only `storage/` layer, and to Phase-III (REST API) by extracting `services/` for API presentation layer.

---

## Complexity Tracking

> No complexity tracking required - no constitution violations requiring justification. All architectural decisions follow constitution principles of simplicity, separation of concerns, and reusability.

---

## Phase 0: Research

### Research-Concurrent Strategy

Research is conducted inline during planning. No concurrent research agents required for Phase-I due to:

- Technology stack is well-defined (Python 3.13+ standard library)
- Domain is straightforward (in-memory todo application)
- Patterns are standard (CLI applications, in-memory data structures)
- No external dependencies or integration complexities

### Lightweight Research Summary

#### CLI Patterns Research

**Decision**: Use Python `argparse` module for command-line parsing.

**Rationale**:
- `argparse` is part of Python standard library (no external dependencies)
- Provides automatic help generation and argument validation
- Supports subcommands and optional arguments natively
- Industry-standard approach for CLI applications

**Alternatives Considered**:
- Manual string parsing: Too error-prone, requires more validation code
- `sys.argv` direct access: Lower level, more manual work for help and validation
- Third-party CLI libraries (`click`, `typer`): Violate constraint to use only standard library

#### In-Memory Data Structure Research

**Decision**: Use Python dictionary with ID-based keys for task storage.

**Rationale**:
- Dictionary provides O(1) lookup by task ID
- Auto-incremented ID generation trivial with integer counter
- Direct mapping matches task access pattern (operations by ID)
- Minimal memory overhead, efficient for up to 1000 tasks

**Alternatives Considered**:
- List-based storage: O(n) lookup, requires iteration to find tasks by ID
- Class-based storage: Over-engineering for simple in-memory requirements
- Third-party data structures: Violate constraint to use only standard library

#### UX Clarity Research

**Decision**: Use consistent command syntax with help on invalid input.

**Rationale**:
- POSIX-style single-word commands (create, view, update, delete)
- Flags for options (--title, --description, --completed, --incomplete)
- Automatic help display on invalid commands reduces user errors
- Clear error messages with actionable guidance improve user experience

**Alternatives Considered**:
- Multi-word commands: More complex parsing, less consistent
- Numbered menu system: Less efficient for power users, requires more interactions
- Questionnaire-style input: Not suitable for repeated task management

---

## Phase 1: Design & Contracts

### Data Model

See `data-model.md` for complete data model specification.

### Contracts

See `contracts/` directory for complete interface contracts:
- `task-contract.md`: Task entity structure and behavior contract
- `command-contract.md`: Command interface contract with all 8 commands

### Quickstart Guide

See `quickstart.md` for user-facing quickstart guide.

---

## Design Decisions Requiring Documentation

### Decision 1: Task ID Generation Strategy

**Decision Description**: How are task IDs generated and managed?

**Available Options**:
- **Option A**: Integer auto-incremented starting from 1, never reused
- **Option B**: UUID-based unique identifiers
- **Option C**: Timestamp-based identifiers

**Trade-offs**:
- **Option A (Integer)**: Simple, predictable, easy for users, but limited to integer range
- **Option B (UUID)**: Guaranteed unique, no collision risk, but not user-friendly (hard to remember)
- **Option C (Timestamp)**: Unique and chronological, but too complex for CLI context

**Final Chosen Direction**: Option A - Integer auto-incremented starting from 1, never reused after deletion.

**Rationale**: Integer IDs are most user-friendly for CLI (easy to remember and type). Auto-increment ensures simplicity. No renumbering after deletion maintains stability and consistency with user expectations.

### Decision 2: CLI Command Style

**Decision Description**: What is the command-line interface style and syntax?

**Available Options**:
- **Option A**: POSIX-style single-word commands with optional flags (e.g., `create Buy groceries -m "Milk, eggs"`)
- **Option B**: Verb-noun pairs (e.g., `add task Buy groceries`)
- **Option C**: Interactive menu-driven system (e.g., select option from numbered list)

**Trade-offs**:
- **Option A (POSIX)**: Efficient for power users, standard CLI conventions, supports scripting
- **Option B (Verb-noun)**: More verbose, harder to remember commands
- **Option C (Menu)**: Easier for beginners, but inefficient for repeated use

**Final Chosen Direction**: Option A - POSIX-style single-word commands with optional flags.

**Rationale**: POSIX style is industry standard, supports efficient task management (users often manage many tasks), and enables future automation or scripting if needed. Optional flags provide flexibility without cluttering primary commands.

### Decision 3: In-Memory Data Structure

**Decision Description**: How are tasks stored and accessed in memory?

**Available Options**:
- **Option A**: Dictionary with task ID as key, task object as value
- **Option B**: List of task objects with index-based access
- **Option C**: Custom class-based storage with methods

**Trade-offs**:
- **Option A (Dictionary)**: O(1) ID lookup, direct mapping to task operations
- **Option B (List)**: O(n) lookup, simpler iteration for view all operations
- **Option C (Class)**: Encapsulation but over-engineering for simple requirements

**Final Chosen Direction**: Option A - Dictionary with task ID as key, task object as value.

**Rationale**: Most task operations are by ID (update, delete, complete), making O(1) lookup critical. Dictionary provides direct mapping. View operations can iterate over dictionary values, meeting all requirements efficiently.

### Decision 4: Error Handling Philosophy

**Decision Description**: How are errors presented to users?

**Available Options**:
- **Option A**: Clear, actionable error messages with command usage
- **Option B**: Minimal error messages with error codes
- **Option C**: Stack traces and detailed technical errors

**Trade-offs**:
- **Option A (Clear messages)**: User-friendly, guides users to correct action
- **Option B (Minimal messages)**: Concise but less helpful for novices
- **Option C (Stack traces)**: Technical but intimidating and unnecessary for CLI application

**Final Chosen Direction**: Option A - Clear, actionable error messages with command usage examples.

**Rationale**: CLI application must be accessible and user-friendly. Clear messages help users correct mistakes quickly. Command usage examples reduce need for referencing help documentation.

### Decision 5: Output Formatting

**Decision Description**: How are tasks displayed to users?

**Available Options**:
- **Option A**: Structured format with status indicator, ID, title, description
- **Option B**: Compact single-line format
- **Option C**: Table-based display with columns

**Trade-offs**:
- **Option A (Structured)**: Clear hierarchy, status visible, description separate from title
- **Option B (Compact)**: Efficient for many tasks but less readable
- **Option C (Table)**: Aligned columns but requires fixed width, harder for long descriptions

**Final Chosen Direction**: Option A - Structured format with status indicator, ID, title, description.

**Rationale**: Structured format with clear status indicators meets requirement for visibility. Separate lines for description improve readability for longer descriptions. Meets success criteria for quick scanning.

---

## Testing & Validation Strategy

### Validation Checks Mapped to Acceptance Criteria

#### User Story 1: Create and View Tasks

| Acceptance Scenario | Validation Check |
|------------------|------------------|
| Create task with title only | System generates ID, stores task, displays success message |
| Create task with title and description | System generates ID, stores task with both fields |
| Create task without title | System displays error message with usage information |
| View tasks after creation | System displays all tasks with correct ID, title, description, status |

#### User Story 2: Mark Tasks as Complete

| Acceptance Scenario | Validation Check |
|------------------|------------------|
| Mark incomplete task as complete | Task status changes to true, view shows [COMPLETED] indicator |
| Mark already completed task as complete | Task remains completed, no error |
| Mark non-existent task as complete | Error message indicates task not found |

#### User Story 3: Update Task Details

| Acceptance Scenario | Validation Check |
|------------------|------------------|
| Update title only | Title changes, description unchanged |
| Update description only | Description changes, title unchanged |
| Update both title and description | Both fields updated to new values |
| Update non-existent task | Error message indicates task not found |

#### User Story 4: Delete Tasks

| Acceptance Scenario | Validation Check |
|------------------|------------------|
| Delete existing task | Task removed from list, view no longer shows task |
| Delete task from middle of list | Remaining tasks display with original IDs (no renumbering) |
| Delete non-existent task | Error message indicates task not found, list unchanged |

#### User Story 5: View Filtered Task Lists

| Acceptance Scenario | Validation Check |
|------------------|------------------|
| View incomplete tasks | Only incomplete tasks displayed |
| View completed tasks | Only completed tasks displayed |
| View filtered when no tasks match | Message indicates no tasks match criteria |

#### Edge Cases Validation

| Edge Case | Validation Check |
|-----------|------------------|
| Create task with empty or whitespace-only title | Error message indicates title cannot be empty |
| Provide non-numeric task ID | Error message indicates invalid ID format |
| Provide negative or zero task ID | Error message indicates invalid ID value |
| Provide extra arguments to any command | Error message indicates unexpected arguments with usage |
| Extremely long title or description | System accepts and displays correctly |
| Special characters in title or description | System accepts and displays correctly |

### How Correctness Will Be Verified WITHOUT Writing Tests Yet

Correctness is verified through specification validation and design completeness:

1. **Specification Completeness**: All user stories have acceptance scenarios mapped to functional requirements
2. **Architecture Consistency**: Design follows architecture specification with clear separation of concerns
3. **Contract Alignment**: Command and task contracts match functional requirements exactly
4. **Edge Case Coverage**: All edge cases from specification have validation checks defined
5. **Success Criteria Mapping**: Each success criterion has corresponding design element:
   - SC-001 (create under 5 seconds): Simple command syntax, direct storage operations
   - SC-002 (view under 1 second): Efficient dictionary iteration, O(n) display
   - SC-003 (update under 5 seconds): Direct dictionary access by ID
   - SC-004 (delete under 3 seconds): Direct dictionary deletion by ID
   - SC-005 (mark completion under 3 seconds): Boolean field update, O(1) access
   - SC-006 (view filtered under 1 second): Filter function with list comprehension
   - SC-007 (1000 tasks without degradation): O(1) lookups, efficient iteration
   - SC-008 (100% first-attempt success): Clear error messages, helpful usage information
   - SC-009 (clear error messages): Actionable error messages with command usage
   - SC-010 (visible status indicators): Structured format with [COMPLETED]/[INCOMPLETE]
   - SC-011 (learn commands in 10 seconds): Built-in help command with all commands listed

Validation is completed through specification-to-design mapping without implementation code generation. Tests will be generated in Phase 2 (`/sp.tasks` command) as part of implementation tasks.

---

## Constitution Re-Check After Design

All constitutional commitments validated post-design:

### Phase-I Constitutional Commitments Re-Verified

- [x] Purpose met: Core functionality established with minimal complexity
- [x] Intelligence added: Data model abstracted, CLI structure reusable, validation rules portable
- [x] Reusable elements identified: Data model in `models/task.py`, CLI structure in `cli/`, validation in `utils/validators.py`
- [x] Unchanged elements preserved: Task entity (id, title, description, completed), CRUD semantics, all user stories

### Evolution Readiness Confirmed

Design prepares for Phase-II evolution:
- Data model abstracted in `models/task.py` can be extracted for persistence layer
- Service layer in `services/task_service.py` separates business logic from storage
- Storage interface in `storage/` allows replacement with file-based persistence in Phase-II
- CLI structure in `cli/` remains consistent, only underlying service evolves

---

## Architecture Sketch

### High-Level Conceptual Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                    Presentation Layer                        │
│  ┌──────────────────────────────────────────────────────┐   │
│  │  CLI Parser → Command Dispatcher → Output Formatter  │   │
│  └────────────────────┬───────────────────────────────┘   │
└───────────────────────┼────────────────────────────────────┘
                        │
                        ▼
┌─────────────────────────────────────────────────────────────────┐
│                  Business Logic Layer                       │
│  ┌──────────────────────────────────────────────┐        │
│  │       Task Service (CRUD + Completion)       │        │
│  └────────────┬────────────────────────────────┘        │
└───────────────┼────────────────────────────────────────────┘
                │
                ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Data Layer                              │
│  ┌──────────────────────────────────────────────┐        │
│  │  In-Memory Store (Dictionary + ID Counter)    │        │
│  └──────────────────────────────────────────────┘        │
└─────────────────────────────────────────────────────────────────┘
```

### Clear Separation of Concerns

#### Presentation Layer (`src/cli/`)

**Responsibilities**:
- Parse user input from stdin
- Validate command syntax
- Route commands to appropriate handlers
- Format output for display
- Display error messages

**No Business Logic**: Layer does not validate task data, enforce business rules, or access storage directly.

#### Business Logic Layer (`src/services/`)

**Responsibilities**:
- Implement task CRUD operations
- Manage task completion status
- Validate task data (title non-empty, ID exists)
- Coordinate with data layer

**No Presentation Logic**: Layer does not format output, display messages, or handle user input directly.

#### Data Layer (`src/storage/`)

**Responsibilities**:
- Store and retrieve tasks from in-memory collection
- Generate and maintain task IDs
- Provide data access methods (get all, get by ID, create, update, delete)

**No Business or Presentation Logic**: Layer does not validate data, enforce rules, or format output.

---

## Evolution Path Confirmation

### Phase-II Preparation

Design enables smooth transition to file persistence:
- Data model in `models/task.py` remains unchanged
- Service layer interface in `services/task_service.py` remains unchanged
- Only storage implementation in `storage/in_memory_store.py` is replaced with `file_store.py`
- CLI layer continues using same service interface

### Phase-III Preparation

Design supports REST API addition:
- Service layer in `services/task_service.py` can be extracted for API use
- Data model and validation logic remain consistent
- CLI becomes alternative presentation layer to REST API

### Phase-IV and V Considerations

Design principles enable future evolution:
- Stateless execution (in-memory state managed explicitly)
- Clear service interfaces enable microservice decomposition
- Separation of concerns supports event-driven architecture

---

## Project Artifacts

### Generated in Phase 0

- `research.md`: Research findings on CLI patterns, in-memory structures, UX clarity

### Generated in Phase 1

- `data-model.md`: Complete task entity definition with validation rules
- `contracts/task-contract.md`: Task entity interface contract
- `contracts/command-contract.md`: Command interface contract with all 8 commands
- `quickstart.md`: User-facing quickstart guide

### To Be Generated in Phase 2

- `tasks.md`: Dependency-ordered task list for implementation (generated by `/sp.tasks` command)

---

## Completion Status

Phase 1 planning is complete. All required artifacts generated:

- [x] Technical context defined
- [x] Constitution check passed (initial and re-check)
- [x] Project structure defined
- [x] Phase 0 research completed
- [x] Phase 1 design complete (data model, contracts, quickstart)
- [x] Design decisions documented with alternatives and rationale
- [x] Testing and validation strategy defined
- [x] Evolution path confirmed for future phases

**Next Step**: Execute `/sp.tasks` to generate dependency-ordered task list for implementation.
