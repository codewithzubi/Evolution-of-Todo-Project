# Hackathon-II: Spec-Driven Development - The Evolution of Todo
## Project Constitution

**Version**: 1.0.0 | **Ratified**: 2025-12-28 | **Last Amended**: 2025-12-28

---

## 1. Project Identity & Vision

### Hackathon Name
Hackathon-II: Spec-Driven Development - The Evolution of Todo
organized by Panaversity / PIAIC / GIAIC

### Project Name
Hackathon-II: AI-Native, Spec-Driven Todo Evolution

### Vision of AI-Native, Spec-Driven Evolution
This project demonstrates the evolution from a simple in-memory CLI todo application to a distributed, cloud-native AI chatbot using Spec-Driven Development. The vision is to prove that:
- AI agents (Claude Code) are the primary implementation authority
- Specifications are the single source of truth
- Architecture and intelligence take precedence over manual coding
- Reusable intelligence scales across phases
- System architects design, AI implements

### Engineer as System Architect
The developer's role is explicitly defined as Product Architect, NOT manual coder. All implementations are generated by Claude Code based on written specifications. The architect focuses on:
- Defining clear requirements and constraints
- Designing architecture and interfaces
- Refining specifications until correct output is achieved
- Validating implementations against specifications
- Ensuring intelligence reusability across phases

---

## 2. Core Development Philosophy

### Spec-Driven Development (SDD)
SDD is the foundational development methodology. All features MUST be specified before implementation. The process:
1. Write specification with user stories and acceptance criteria
2. Generate implementation plan from specification
3. Create actionable, dependency-ordered tasks
4. Delegate implementation to Claude Code
5. Validate implementation against specification
6. Refine specification if output is incorrect

### AI-Native Engineering
The project is AI-native by design. AI is not an assistant but the primary implementation engine. This means:
- Claude Code is the only implementation authority
- Intelligence is encapsulated in skills and subagents
- Manual code writing is prohibited
- Specs are refined until AI generates correct output
- AI handles generation, testing, and documentation

### Architecture over Syntax
The architect focuses on architecture, not syntax. Principles:
- Define interfaces, contracts, and data models first
- Establish communication patterns and boundaries
- Design for evolution and reusability
- Let AI handle syntax and implementation details
- Architecture decisions documented in ADRs

### Intelligence over Boilerplate
The project prioritizes reusable intelligence over repetitive code:
- Skills encapsulate reusable behaviors
- Subagents specialize in specific domains
- Patterns prevent duplication
- Abstractions enable cross-phase reusability
- Boilerplate is generated, not manually written

---

## 3. Absolute Non-Negotiable Rules

### Manual Code Writing is Strictly Forbidden
Developers MUST NOT write any implementation code. All code MUST be generated by Claude Code based on specifications. Violation invalidates the implementation.

### Every Feature MUST Have a Written Specification
No feature can be implemented without a written specification in `specs/[feature-name]/spec.md`. The specification MUST include user stories, acceptance criteria, requirements, and success criteria.

### Claude Code is the Only Implementation Authority
All implementations must be generated via Claude Code commands (`/sp.specify`, `/sp.plan`, `/sp.tasks`, `/sp.implement`). Manual implementation or use of other tools violates this rule.

### Specs Must Be Refined Until Correct Output is Generated
If Claude Code generates incorrect or incomplete output, the specification MUST be refined, not the code corrected manually. The architect iterates on the specification until the AI produces valid results.

### Phases Must Be Completed Sequentially
The project progresses through phases I, II, III, IV, V sequentially. No phase can be skipped or implemented out of order. Each phase MUST build upon and preserve all previous functionality.

---

## 4. Spec Governance Model

### Types of Specs

#### Feature Specs
Define user-facing functionality. MUST include:
- User stories with priorities (P1, P2, P3)
- Acceptance scenarios (Given-When-Then)
- Functional requirements
- Key entities
- Success criteria

**Location**: `specs/[feature-name]/spec.md`

#### API Specs
Define service interfaces. Must include:
- Endpoint definitions (methods, paths, inputs, outputs)
- Request/response schemas
- Error taxonomy and status codes
- Rate limits and timeouts
- Authentication requirements

**Location**: `specs/[feature-name]/contracts/` or `specs/[feature-name]/plan.md`

#### Database Specs
Define data persistence. Must include:
- Entity definitions and relationships
- Schema evolution strategy
- Migration and rollback plans
- Data retention policies

**Location**: `specs/[feature-name]/data-model.md`

#### UI Specs
Define user interfaces. Must include:
- Screen layouts and components
- User flows and interactions
- Responsive design requirements
- Accessibility considerations

**Location**: `specs/[feature-name]/plan.md` or dedicated UI spec

#### Agent & MCP Tool Specs
Define AI behavior. Must include:
- Agent responsibilities and capabilities
- Tool definitions and inputs/outputs
- Skill invocation rules
- State management and persistence

**Location**: `specs/[feature-name]/plan.md` or dedicated agent spec

### Spec Versioning
Specifications follow semantic versioning (MAJOR.MINOR.PATCH):
- **MAJOR**: Breaking changes to user-facing functionality or interfaces
- **MINOR**: New features or capabilities added
- **PATCH**: Clarifications, typo fixes, non-semantic changes

Version history MUST be tracked in the spec document.

### Spec as Single Source of Truth
Specifications are the authoritative source for:
- Feature requirements
- Interface contracts
- Data models
- Behavior expectations

Any conflicts between specifications and implementations MUST be resolved by updating the specification, not the implementation.

---

## 5. Reusable Intelligence Doctrine

### Definition of Reusable Intelligence
Reusable Intelligence represents encapsulated, abstracted behavior or capabilities that can be invoked across multiple contexts without duplication. It includes:
- Skills: Parameterized behaviors that perform specific tasks
- Subagents: Specialized AI agents with defined responsibilities
- Patterns: Reusable architectural or implementation patterns
- Templates: Pre-configured structures for common use cases

### Definition of Subagents
Subagents are specialized AI agents with narrowly defined responsibilities. Each subagent:
- Has a specific domain or capability focus
- Operates autonomously within its scope
- Communicates via well-defined interfaces
- Maintains no long-term state (stateless execution)

**Examples**:
- Database Schema Subagent: Generates and validates database schemas
- API Contract Subagent: Designs REST/GraphQL interfaces
- Test Generation Subagent: Creates test cases based on specs
- Deployment Subagent: Generates Kubernetes manifests

### Definition of Skills
Skills are parameterized, reusable behaviors that encapsulate specific functionality. Each skill:
- Accepts defined inputs and produces predictable outputs
- Is independent of context (no hardcoded assumptions)
- Can be invoked by multiple agents or subagents
- Has clear documentation and usage examples

**Examples**:
- `json-schema-validator`: Validates JSON against a schema
- `markdown-formatter`: Formats Markdown documents consistently
- `dependency-installer`: Installs dependencies across multiple languages
- `test-runner`: Executes test suites and reports results

### Rules for Reusable Intelligence

#### Skill Reuse Across Phases
Skills MUST be designed for reuse across all phases. Once a skill is created, it MUST:
- Be versioned and documented
- Work independently of phase-specific context
- Be used in all applicable phases without modification
- Only be enhanced, not replaced

**Example**: A `todo-model-generator` skill created in Phase II MUST be reused in Phases III-V to ensure consistency.

#### Subagent Specialization
Subagents MUST remain specialized and avoid scope creep. Each subagent:
- Has ONE primary responsibility
- Delegates non-core tasks to other subagents
- Does not duplicate capabilities of other subagents
- Communicates via standardized interfaces

**Example**: A `SchemaAgent` generates schemas but does NOT implement API endpoints (delegates to `APIAgent`).

#### No Duplication of Intelligence
Intelligence MUST NOT be duplicated. If a skill or pattern exists, it MUST be reused rather than reimplemented. Duplication includes:
- Reimplementing existing skills in new phases
- Creating multiple skills for the same purpose
- Hardcoding behavior that could be abstracted

**Violations**: Creating a new JSON parsing skill when one already exists; reimplementing authentication logic in each microservice.

### Conceptual Examples (No Code)

#### Skill Reuse Example
A `date-formatter` skill accepts a date and a format string, returning the formatted date. This skill is used in:
- Phase II: Formatting dates in CLI output
- Phase III: Formatting dates in JSON API responses
- Phase IV: Formatting dates in event logs
- Phase V: Formatting dates in AI chat responses

The skill remains unchanged across all phases; only the invocation context differs.

#### Subagent Specialization Example
Three subagents collaborate on API design:
1. `SchemaAgent`: Designs data models and schemas
2. `APIAgent`: Designs REST endpoints and contracts
3. `DocAgent`: Generates API documentation

Each agent operates independently. The `APIAgent` does NOT define schemas; it requests schemas from `SchemaAgent` via a standardized interface.

---

## 6. AI Agent Architecture

### Main Orchestrator Agent
The Main Orchestrator Agent is responsible for:
- Interpreting specifications and user commands
- Coordinating subagents and skills
- Managing execution flow and dependencies
- Validating outputs against specifications
- Generating artifacts (code, docs, configs)

**Invocation**: Via Claude Code `/sp.*` commands

**Capabilities**:
- `/sp.specify`: Create or update feature specifications
- `/sp.plan`: Generate implementation plans
- `/sp.tasks`: Generate actionable task lists
- `/sp.implement`: Execute implementation tasks
- `/sp.adr`: Create Architecture Decision Records

### Subagent Responsibilities
Subagents are specialized and autonomous. Each has a defined scope:

| Subagent | Responsibility | Inputs | Outputs |
|----------|----------------|--------|---------|
| `SpecAgent` | Analyze and refine specifications | User input, existing specs | Validated specs, clarification questions |
| `PlanAgent` | Generate implementation plans | Validated specs | Architecture documents, design artifacts |
| `TaskAgent` | Generate task lists | Plans, specs | Dependency-ordered tasks |
| `ImplAgent` | Execute implementation tasks | Tasks, plans | Source code, tests, configs |
| `TestAgent` | Generate and execute tests | Specs, code | Test results, coverage reports |
| `DocAgent` | Generate documentation | Specs, code, plans | Documentation files |
| `DeployAgent` | Generate deployment artifacts | Code, configs | Kubernetes manifests, Dockerfiles |

### Skill Invocation Rules
Skills are invoked by agents based on task requirements. Invocation rules:
1. **Existing Skills First**: Before creating new skills, check for existing ones
2. **Parameterized Invocation**: Pass all required parameters explicitly
3. **Context Independence**: Skills must work without external context
4. **Error Handling**: Skills must handle errors gracefully and return meaningful messages

**Example**: The `ImplAgent` invokes the `json-schema-validator` skill to validate generated API responses before finalizing implementation.

### MCP Tool Usage
Model Context Protocol (MCP) tools provide external capabilities. Usage rules:
- MCP tools are invoked for external system interactions (e.g., file I/O, command execution)
- Agents MUST prefer MCP tools over manual operations
- MCP tool failures MUST be surfaced clearly to the orchestrator
- No hardcoded paths or environment assumptions in MCP usage

### Stateless Execution Philosophy
All agents and subagents execute statelessly. This means:
- No persistent state between invocations
- All context passed explicitly as inputs
- No reliance on global variables or external state
- Results are deterministic given the same inputs

**Benefits**: Reproducibility, testability, scalability across distributed environments.

---

## 7. Phase-Wise Constitutional Commitments

### Phase I: In-Memory Python CLI Todo App

**Purpose**: Establish core functionality with minimal complexity. Prove SDD methodology with a simple implementation.

**Intelligence Added**:
- Basic todo data model (in-memory)
- CLI interface for CRUD operations
- Simple input validation

**What Must Remain Reusable**:
- Data model (can be abstracted for later persistence)
- CLI command structure
- Validation rules

**What Must Remain Unchanged**:
- User stories and acceptance criteria
- Core todo entity definition
- CRUD operation semantics

### Phase II: File-Persisted CLI Todo with Data Models

**Purpose**: Add persistence and data modeling. Demonstrate evolution while maintaining backward compatibility.

**Intelligence Added**:
- File-based persistence layer
- Serialization/deserialization patterns
- Data schema validation

**What Must Remain Reusable**:
- Persistence abstraction (for future database)
- Serialization patterns
- Schema validation logic

**What Must Remain Unchanged**:
- All Phase I functionality
- CLI interface
- Todo entity definition
- User stories

### Phase III: REST API Todo Service with Web Frontend

**Purpose**: Move to client-server architecture. Introduce web technologies and REST APIs.

**Intelligence Added**:
- REST API design and implementation
- Web frontend (React or equivalent)
- HTTP request/response handling
- JSON serialization

**What Must Remain Reusable**:
- API contracts and schemas
- Frontend component patterns
- HTTP client/server abstractions

**What Must Remain Unchanged**:
- All Phase I-II functionality
- Todo entity definition
- CRUD operation semantics
- Data model

### Phase IV: Event-Driven Todo with Microservices

**Purpose**: Introduce microservices and event-driven architecture. Demonstrate distributed system design.

**Intelligence Added**:
- Microservice decomposition
- Event sourcing and messaging (Kafka)
- Service communication patterns
- Distributed state management

**What Must Remain Reusable**:
- Service interfaces and contracts
- Event schemas
- Communication patterns
- Orchestration logic

**What Must Remain Unchanged**:
- All Phase I-III functionality
- Todo entity definition
- Core business logic
- API contracts

### Phase V: Distributed Cloud-Native AI Todo Chatbot on Kubernetes

**Purpose**: Achieve full cloud-native, AI-driven system. Complete evolution demonstration.

**Intelligence Added**:
- Kubernetes deployment
- Dapr abstraction layer
- AI chatbot integration
- Distributed tracing and observability

**What Must Remain Reusable**:
- Kubernetes manifests
- Dapr component configurations
- AI interaction patterns
- Observability instrumentation

**What Must Remain Unchanged**:
- All Phase I-IV functionality
- Todo entity definition
- Core business logic
- API contracts
- Event schemas

---

## 8. Cloud-Native & Infrastructure Principles

### Stateless Services
All services MUST be stateless:
- No in-memory state across requests
- All state persisted externally (database, cache, message queue)
- Services can be scaled horizontally without coordination
- Stateless design enables Kubernetes deployment patterns

**Rationale**: Statelessness enables scalability, resilience, and operational simplicity.

### Kubernetes-First Mindset
All deployments target Kubernetes:
- Services are containerized (Docker)
- Kubernetes manifests define deployments, services, configs
- Horizontal Pod Autoscaling for elasticity
- ConfigMaps and Secrets for configuration management

**Rationale**: Kubernetes provides standard deployment patterns, resilience, and operational tooling.

### Event-Driven Architecture
Communication between services follows event-driven patterns:
- Services communicate via events (Kafka topics)
- Producers publish events, consumers subscribe
- Decoupled service boundaries via message queues
- Event schemas versioned and documented

**Rationale**: Event-driven architecture enables loose coupling, scalability, and auditability.

### Kafka Usage Philosophy
Kafka is the message broker for event-driven communication:
- Persistent event logs for replayability
- Topic design by domain (e.g., `todo-created`, `todo-updated`)
- Consumer groups for parallel processing
- Exactly-once semantics where required

**Rules**:
- Events MUST be schema-validated (JSON Schema or Avro)
- Event fields MUST include metadata (timestamp, correlation ID, source)
- Dead letter queues for failed events
- Idempotent consumers to handle duplicates

### Dapr Abstraction Rules
Dapr provides abstraction for distributed primitives:
- Use Dapr bindings for external service integration
- Use Dapr state management for caching
- Use Dapr pub/sub for messaging (abstraction over Kafka)
- Use Dapr actors for stateful entities (if needed)

**Rules**:
- Direct Kafka/Kubernetes usage is allowed but Dapr is preferred
- Dapr configurations are stored in Kubernetes resources
- Dapr sidecar injection is automatic via annotations

---

## 9. Security & Authentication Principles

### JWT-Based Authentication
All API endpoints require JWT authentication:
- JWTs issued by an authentication service
- JWTs include claims: user ID, expiration, permissions
- JWTs validated on every request
- Refresh token flow for session renewal

**Rationale**: JWTs provide stateless authentication suitable for distributed systems.

### User Isolation
User data MUST be strictly isolated:
- All queries include user ID in WHERE clauses
- Multi-tenant data isolation at database level
- No cross-user data access without explicit authorization
- Row-level security or equivalent mechanisms

**Rationale**: User isolation prevents data leaks and ensures privacy.

### Zero-Trust Service Communication
Service-to-service communication follows zero-trust principles:
- Mutual TLS (mTLS) for all inter-service communication
- Service identities validated via certificates
- No implicit trust based on network location
- All requests include authentication tokens

**Rationale**: Zero-trust security prevents lateral movement and insider threats.

### Secrets Management Discipline
Secrets MUST never be hardcoded:
- Secrets stored in Kubernetes Secrets or external vault
- Environment variable injection from Secrets
- No secrets in code, configs, or logs
- Secret rotation policies defined and enforced

**Rationale**: Secret management prevents credential leakage and enables auditing.

---

## 10. Quality, Correctness & Evaluation Standards

### Definition of Correctness
Correctness is defined as:
1. **Specification Adherence**: Implementation matches specification exactly
2. **Functional Correctness**: All acceptance criteria pass
3. **Non-Functional Requirements**: Performance, security, reliability meet requirements
4. **Integration Validity**: All integrations work as specified

A system is incorrect if ANY of these criteria fail.

### Definition of Completion
Completion is achieved when:
1. All user stories in the specification are implemented
2. All acceptance criteria pass
3. All non-functional requirements are validated
4. Documentation is complete and up-to-date
5. Tests (if required) pass with acceptable coverage
6. Demo validates the feature end-to-end

Partial completion is NOT completion. All requirements must be met.

### Definition of Excellence
Excellence goes beyond correctness:
1. **Elegant Architecture**: Clean separation of concerns, minimal coupling
2. **Comprehensive Testing**: High test coverage, edge cases covered
3. **Clear Documentation**: Well-documented code, specs, and APIs
4. **Operational Excellence**: Monitoring, logging, alerting in place
5. **Reusable Intelligence**: Skills, patterns, abstractions leveraged

### Alignment with Hackathon Judging Criteria
The project aligns with Hackathon-II judging criteria:
- **SDD Compliance**: All work is spec-driven
- **AI-Native Approach**: Implementation delegated to Claude Code
- **Phased Evolution**: All phases completed sequentially
- **Reusable Intelligence**: Skills and patterns reused across phases
- **Documentation**: Complete specs, plans, tasks, and ADRs
- **Transparency**: GitHub repository fully documented
- **Demo Quality**: End-to-end demonstration of evolution

---

## 11. Documentation & Submission Discipline

### GitHub Repository Expectations
The GitHub repository MUST contain:

```
specs/
|-- phase-i-in-memory-cli/
|   |-- spec.md
|   |-- plan.md
|   |-- tasks.md
|   |-- contracts/
|-- phase-ii-file-persisted/
|   |-- ...
|-- phase-iii-rest-api/
|   |-- ...
|-- phase-iv-event-driven/
|   |-- ...
|-- phase-v-cloud-native/
    |-- ...

history/
|-- adr/
|   |-- 001-phase-i-architecture.md
|   |-- 002-persistence-strategy.md
|   |-- ...
|-- prompts/
    |-- constitution/
    |-- phase-i-in-memory-cli/
    |-- phase-ii-file-persisted/
    |-- phase-iii-rest-api/
    |-- phase-iv-event-driven/
    |-- phase-v-cloud-native/

.specify/
|-- memory/
|   |-- constitution.md (this file)
|-- templates/
|   |-- spec-template.md
|   |-- plan-template.md
|   |-- tasks-template.md
|   |-- ...
|-- scripts/
```

### Specs Folder Discipline
Each phase MUST have a dedicated folder under `specs/`. Each folder MUST contain:
- `spec.md`: Feature specification with user stories
- `plan.md`: Implementation plan with architecture decisions
- `tasks.md`: Dependency-ordered task list
- `contracts/`: API contracts and data models
- `quickstart.md`: Quickstart guide for the phase

### Demo Video Rules
The demo video MUST:
- Demonstrate each phase independently (5 segments)
- Show evolution from Phase I to Phase V
- Include CLI walkthrough for Phases I-II
- Include web interface for Phase III
- Include event flow visualization for Phase IV
- Include Kubernetes deployment and AI chat for Phase V
- Be 10-15 minutes total
- Include voice narration explaining SDD methodology

### Transparency for Judges
Judges MUST be able to:
- Review all specifications in `specs/`
- Trace implementation from specs to code
- See all ADRs in `history/adr/`
- Review PHRs in `history/prompts/`
- Understand the SDD process via the demo
- Validate compliance with the constitution

---

## 12. Constitutional Enforcement Clause

### Constitution Overrides Convenience
This Constitution overrides all convenience considerations. If a faster or easier approach violates the Constitution, it MUST NOT be used. Examples:
- Writing code directly to save time: PROHIBITED
- Skipping a phase to reach final state: PROHIBITED
- Duplicating intelligence instead of reusing: PROHIBITED
- Modifying code without updating specs: PROHIBITED

### Violations Invalidate Implementations
Any implementation that violates the Constitution is INVALID. Violations include:
- Code written without a specification
- Features implemented out of phase order
- Intelligence duplicated instead of reused
- Specifications not updated after implementation

Violated implementations MUST be rejected and redone following proper process.

### Long-Term Maintainability Over Shortcuts
Long-term maintainability takes priority over shortcuts. The project demonstrates:
- Clean architecture over quick fixes
- Reusable intelligence over one-off code
- Comprehensive documentation over minimal notes
- Proper testing over manual validation

The hackathon judges evaluate maintainability, not just initial functionality.

---

## Governance

### Amendment Process
Constitution amendments require:
1. Documented proposal with rationale
2. Review of impact on existing phases and specs
3. Approval via commit with proper message format
4. Version increment following semantic versioning
5. Update to this document and dependent templates

### Versioning Policy
Constitution follows semantic versioning:
- **MAJOR**: Backward-incompatible principle removal or redefinition
- **MINOR**: New principle or section added
- **PATCH**: Clarifications, typo fixes, non-semantic changes

### Compliance Review
All development work must comply with this Constitution. Before finalizing any phase:
1. Review implementation against Constitution rules
2. Verify all specifications are complete and up-to-date
3. Validate reusability of intelligence
4. Confirm phase sequential completion
5. Document any exceptions with justification

Non-compliant work MUST be corrected before submission.

---

## Sync Impact Report

### Version Change
- Previous: None (initial version)
- New: 1.0.0

### Modified Principles
- None (initial creation)

### Added Sections
- All sections (initial creation)
  1. Project Identity & Vision
  2. Core Development Philosophy
  3. Absolute Non-Negotiable Rules
  4. Spec Governance Model
  5. Reusable Intelligence Doctrine
  6. AI Agent Architecture
  7. Phase-Wise Constitutional Commitments
  8. Cloud-Native & Infrastructure Principles
  9. Security & Authentication Principles
  10. Quality, Correctness & Evaluation Standards
  11. Documentation & Submission Discipline
  12. Constitutional Enforcement Clause

### Removed Sections
- None (initial creation)

### Templates Requiring Updates

#### Templates Updated (via placeholder analysis)
- `.specify/templates/plan-template.md`: Contains "Constitution Check" section that references principles
- `.specify/templates/spec-template.md`: Defines structure for specs that align with "Spec Governance Model"
- `.specify/templates/tasks-template.md`: Defines task organization that aligns with "Reusable Intelligence Doctrine"

#### Templates Pending Manual Review
- `.specify/templates/commands/sp.adr.md`: Does not exist - check if needed
- `.specify/templates/phr-template.prompt.md`: Needs review for constitution alignment

### Follow-up TODOs
- None (all placeholders resolved)

---

**End of Constitution**
