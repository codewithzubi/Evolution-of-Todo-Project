# Research & Architectural Decisions: Task CRUD Operations

**Feature**: 002-task-crud
**Date**: 2026-02-09
**Status**: Phase 0 Complete

## Overview

This document captures research findings and architectural decisions for implementing complete CRUD operations for task management with strong user data isolation, optimistic UI updates, and support for 1000+ tasks without performance degradation.

## Key Decisions

### 1. Database Schema Design with User-Scoped Security

**Decision**: Task entity with user_id foreign key, indexed for query performance

**Rationale**:
- Constitution requires 100% data isolation between users
- Foreign key ensures referential integrity (tasks belong to valid users)
- Index on user_id enables fast filtering for user-specific queries
- Composite index on (user_id, created_at) optimizes default sort order

**SQLModel Schema**:
```python
class Task(SQLModel, table=True):
    id: int | None = Field(default=None, primary_key=True)
    user_id: int = Field(foreign_key="user.id", index=True)
    title: str = Field(max_length=200)
    description: str | None = Field(default=None, max_length=1000)
    is_completed: bool = Field(default=False)
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

**Alternatives Considered**:
- **Rejected: Soft delete with is_deleted flag** - Constitution specifies permanent deletion, adds query complexity
- **Rejected: Separate tables per user** - Violates database normalization, unscalable
- **Rejected: No foreign key constraint** - Allows orphaned tasks, violates data integrity

**Implementation Approach**:
- SQLModel ORM for type-safe database access
- Alembic migration to create tasks table with indexes
- All queries MUST include `WHERE user_id = {jwt_user_id}` filter
- Database-level constraint prevents cross-user data access

---

### 2. API Endpoint Design (RESTful CRUD)

**Decision**: 5 RESTful endpoints following standard HTTP methods

**Rationale**:
- RESTful conventions are well-understood and predictable
- HTTP methods map naturally to CRUD operations
- Stateless design aligns with JWT authentication
- Easy to test with standard HTTP clients

**Endpoint Design**:
1. **GET /api/tasks?status={all|pending|completed}** - List tasks with optional filter
2. **POST /api/tasks** - Create new task (body: {title, description?})
3. **PATCH /api/tasks/{task_id}/toggle** - Toggle completion status
4. **PUT /api/tasks/{task_id}** - Update task (body: {title, description?})
5. **DELETE /api/tasks/{task_id}** - Delete task permanently

**Alternatives Considered**:
- **Rejected: GraphQL** - Overkill for simple CRUD, adds complexity
- **Rejected: RPC-style endpoints** - Less standard, harder to cache
- **Rejected: Separate endpoints for complete/uncomplete** - PATCH toggle is simpler

**Implementation Approach**:
- FastAPI route handlers in backend/app/api/tasks.py
- JWT validation via Depends(get_current_user) dependency
- Pydantic models for request/response validation
- OpenAPI schema auto-generated by FastAPI

---

### 3. State Management Strategy (TanStack Query)

**Decision**: TanStack Query v5 for server state with optimistic updates

**Rationale**:
- Constitution requires optimistic UI updates (FR-023)
- TanStack Query provides built-in optimistic update patterns
- Automatic cache invalidation and refetching
- Handles loading/error states declaratively
- No need for global state management (Redux, Zustand)

**Query/Mutation Pattern**:
```typescript
// Query for fetching tasks
const { data: tasks } = useQuery({
  queryKey: ['tasks', filter],
  queryFn: () => fetchTasks(filter)
})

// Mutation for toggling completion with optimistic update
const toggleMutation = useMutation({
  mutationFn: toggleTask,
  onMutate: async (taskId) => {
    // Optimistic update: immediately update UI
    await queryClient.cancelQueries(['tasks'])
    const previous = queryClient.getQueryData(['tasks'])
    queryClient.setQueryData(['tasks'], (old) =>
      old.map(t => t.id === taskId ? {...t, is_completed: !t.is_completed} : t)
    )
    return { previous }
  },
  onError: (err, variables, context) => {
    // Rollback on error
    queryClient.setQueryData(['tasks'], context.previous)
  },
  onSettled: () => {
    // Refetch to ensure consistency
    queryClient.invalidateQueries(['tasks'])
  }
})
```

**Alternatives Considered**:
- **Rejected: Redux Toolkit** - Too much boilerplate for server state
- **Rejected: SWR** - Less powerful optimistic update API than TanStack Query
- **Rejected: Manual fetch + useState** - No caching, no optimistic updates, error-prone

**Implementation Approach**:
- Custom hooks in frontend/lib/hooks/use-tasks.ts
- Separate mutations for each CRUD operation
- Optimistic updates for toggle and delete (instant feedback)
- Pessimistic updates for create and edit (wait for server confirmation)

---

### 4. Modal vs Inline Editing Approach

**Decision**: Modal dialogs for create and edit, inline checkbox for toggle, confirmation dialog for delete

**Rationale**:
- Modals provide focused context for form input (title + description)
- Prevents accidental edits while browsing tasks
- shadcn/ui Dialog component provides accessible modal implementation
- Inline checkbox for toggle provides instant feedback (no modal friction)
- Confirmation dialog prevents accidental deletion

**Alternatives Considered**:
- **Rejected: Inline editing** - Complex to implement, easy to trigger accidentally, poor mobile UX
- **Rejected: Separate page for edit** - Breaks flow, requires navigation, slower UX
- **Rejected: No confirmation for delete** - Too risky, violates FR-017

**Implementation Approach**:
- AddTaskModal: shadcn Dialog with form (title input, description textarea)
- EditTaskModal: Same as AddTaskModal but pre-filled with current data
- DeleteConfirmDialog: shadcn AlertDialog with "Cancel" and "Delete" buttons
- Checkbox on task card: Direct onClick handler, no modal

---

### 5. Filtering Implementation (Client-Side)

**Decision**: Client-side filtering with single API call fetching all tasks

**Rationale**:
- Simpler implementation (no query parameters, no server-side filtering logic)
- Faster filter switching (no network round-trip)
- Acceptable for 1000+ tasks (filtering is O(n) but fast in JavaScript)
- Reduces API complexity and server load

**Filtering Logic**:
```typescript
const filteredTasks = useMemo(() => {
  if (filter === 'pending') return tasks.filter(t => !t.is_completed)
  if (filter === 'completed') return tasks.filter(t => t.is_completed)
  return tasks // 'all'
}, [tasks, filter])
```

**Alternatives Considered**:
- **Rejected: Server-side filtering** - More complex, requires query parameters, slower filter switching
- **Rejected: Separate endpoints per filter** - Violates DRY, cache invalidation complexity

**Implementation Approach**:
- Single GET /api/tasks endpoint returns all user tasks
- Frontend filters in memory based on sidebar selection
- Filter state managed with React useState (URL query param optional)

---

### 6. Performance Optimization for 1000+ Tasks

**Decision**: Multi-layered optimization strategy

**Rationale**:
- Success criteria requires <2s load time for 1000+ tasks (SC-006)
- 60fps scrolling on mobile (SC-009)
- Combination of database, API, and frontend optimizations

**Optimization Techniques**:

**Database Layer**:
- Composite index on (user_id, created_at) for fast sorted queries
- Limit query to essential fields (no unnecessary joins)
- Connection pooling for concurrent requests

**API Layer**:
- Pagination support (optional, for future enhancement if >1000 tasks)
- Gzip compression for JSON responses
- HTTP caching headers (ETag, Cache-Control)

**Frontend Layer**:
- Virtual scrolling for task grid (react-window or @tanstack/react-virtual)
- Memoization of filtered tasks (useMemo)
- Lazy loading of task descriptions (truncate in card, full text on hover/click)
- Debounced search (if search feature added later)

**Alternatives Considered**:
- **Rejected: Infinite scroll** - Adds complexity, harder to implement filters
- **Rejected: Server-side pagination** - Breaks "view all tasks" requirement, complicates filtering

**Implementation Approach**:
- Start with simple implementation (no virtual scrolling)
- Add virtual scrolling only if performance testing shows need
- Monitor with React DevTools Profiler

---

### 7. JWT Validation Approach

**Decision**: FastAPI dependency injection with get_current_user

**Rationale**:
- Reuses authentication infrastructure from 001-user-auth
- Declarative security (Depends(get_current_user) on all endpoints)
- Automatic 401 response if JWT invalid or missing
- User ID extracted from JWT claims for query filtering

**Implementation Pattern**:
```python
@router.get("/api/tasks")
async def list_tasks(
    current_user: User = Depends(get_current_user),
    session: Session = Depends(get_session)
):
    # current_user.id automatically extracted from JWT
    tasks = session.exec(
        select(Task).where(Task.user_id == current_user.id)
    ).all()
    return tasks
```

**Alternatives Considered**:
- **Rejected: Manual JWT validation in each endpoint** - Violates DRY, error-prone
- **Rejected: Middleware-based validation** - Less explicit, harder to test

**Implementation Approach**:
- Import get_current_user from backend/app/api/deps.py (from 001-user-auth)
- Add Depends(get_current_user) to all task endpoints
- Use current_user.id for all database queries

---

### 8. Error Handling Strategy

**Decision**: Layered error handling with user-friendly messages

**Rationale**:
- Constitution requires graceful error handling (FR-024)
- Users should never see raw error messages or stack traces
- Different error types require different handling strategies

**Error Categories**:

**Validation Errors (400)**:
- Title required, title too long, description too long
- Frontend validation (immediate feedback) + backend validation (security)
- User-friendly messages: "Title is required", "Title must be 200 characters or less"

**Authentication Errors (401)**:
- Invalid JWT, expired JWT, missing JWT
- Redirect to login page
- Message: "Your session has expired. Please log in again."

**Authorization Errors (403)**:
- User trying to access another user's task
- Should never happen if frontend is correct, but backend must enforce
- Message: "You don't have permission to access this task"

**Not Found Errors (404)**:
- Task doesn't exist or was deleted
- Message: "Task not found. It may have been deleted."

**Server Errors (500)**:
- Database connection failure, unexpected errors
- Message: "Something went wrong. Please try again later."
- Log error details server-side for debugging

**Implementation Approach**:
- Backend: FastAPI exception handlers for each error type
- Frontend: TanStack Query error handling in onError callbacks
- Toast notifications for error messages (shadcn/ui Sonner)

---

## Technology Stack Summary

| Category | Technology | Version | Justification |
|----------|-----------|---------|---------------|
| Backend Framework | FastAPI | 0.128.5 | Constitution-locked, async support, auto OpenAPI docs |
| ORM | SQLModel | 0.0.32 | Constitution-locked, type-safe, Pydantic integration |
| Database | PostgreSQL (Neon) | Latest | Constitution-locked, relational data, ACID compliance |
| Frontend Framework | Next.js | 16.1.6 | Constitution-locked, App Router, Server Components |
| State Management | TanStack Query | v5 | Optimistic updates, caching, automatic refetching |
| UI Components | shadcn/ui | Latest | Constitution-approved, Dialog, Card, Button, Input |
| Icons | Lucide React | Latest | Constitution-required, tree-shakeable |
| Backend Testing | pytest | Latest | Python standard, TestClient for API tests |
| Frontend Testing | Vitest + Playwright | Latest | Fast unit tests, reliable E2E tests |

---

## Performance Budget

| Metric | Target | Strategy |
|--------|--------|----------|
| View Tasks | <1s | Indexed queries, client-side filtering, memoization |
| Create Task | <10s | Optimistic UI, async API call, toast notification |
| Toggle Complete | <100ms | Optimistic update, instant visual feedback |
| Edit Task | <15s | Pre-filled form, optimistic UI, validation |
| Delete Task | <5s | Confirmation dialog, optimistic removal |
| 1000+ Tasks | <2s load | Database indexes, virtual scrolling (if needed) |
| Mobile Scrolling | 60fps | CSS transforms, avoid layout thrashing |
| API Success Rate | 95%+ | Error handling, retry logic, graceful degradation |

---

## Security Checklist

- ✅ JWT validation on all endpoints (Depends(get_current_user))
- ✅ User ID filtering on all queries (WHERE user_id = current_user.id)
- ✅ SQL injection prevention (SQLModel parameterized queries)
- ✅ XSS prevention (React auto-escapes, sanitize if using dangerouslySetInnerHTML)
- ✅ CSRF prevention (SameSite cookies from 001-user-auth)
- ✅ Rate limiting (100 tasks per minute per user)
- ✅ Input validation (frontend + backend)
- ✅ Foreign key constraints (tasks.user_id → users.id)

---

## Risk Mitigation

### Risk 1: Performance Degradation with 1000+ Tasks
**Mitigation**:
- Database indexes on user_id and created_at
- Virtual scrolling if simple grid is too slow
- Pagination as fallback (future enhancement)
- Load testing with 1000+ tasks before deployment

### Risk 2: Optimistic Update Conflicts
**Mitigation**:
- TanStack Query rollback on error
- Refetch after mutation to ensure consistency
- Show error toast if update fails
- Prevent rapid-fire clicks with debouncing

### Risk 3: Cross-User Data Leakage
**Mitigation**:
- Enforce user_id filtering at database query level
- Integration tests verifying data isolation
- Code review checklist for all queries
- Automated security testing

---

## Open Questions

None - all technical decisions resolved. Task CRUD is a well-understood domain with established patterns.

---

## Next Steps

Proceed to Phase 1:
1. Generate data-model.md (Task and User entities with relationships)
2. Generate contracts/tasks.openapi.yaml (5 API endpoints)
3. Generate quickstart.md (test scenarios for all CRUD operations)
4. Update agent context (CLAUDE.md)
5. Re-evaluate Constitution Check (expected: still PASS)
