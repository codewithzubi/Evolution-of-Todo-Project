# Evolution of Todo: Phase 2 & 3 Constitution

**Project**: Evolution of Todo (Full-Stack Web Application + AI Chatbot)
**Phases**: Phase 2 (Console → Web with Multi-User, Persistent Storage, Authentication) + Phase 3 (AI Chatbot Integration)
**Version**: 3.0.0
**Ratified**: 2026-02-01
**Last Amended**: 2026-02-07

---

## Sync Impact Report

- **Version Change**: 2.0.0 → 3.0.0 (MINOR: Phase-III added as new section; Phase-II preserved unchanged; new principles for AI chatbot integration, MCP architecture, OpenAI stack)
- **Modified Principles**: Progressive Evolution Architecture (updated roadmap to reflect Phase 3), Feature Requirements & Constraints (added Phase 3 AI chatbot scope)
- **Added Sections**: 6 new Phase-III principles (AI Stack, MCP Architecture, Conversational Safety, Stateless Persistence, Chat UI Integration, Database Extensions)
- **Removed Sections**: None; Phase-II remains complete and authoritative
- **Templates Updated**: ⚠ Pending: spec-template.md (AI features), plan-template.md (agent orchestration), tasks-template.md (MCP + agent tasks)
- **Follow-up TODOs**: None; all Phase-III principles concrete and enforceable

---

## Phase-II Constitution (Preserved: Version 2.0.0)

---

## 1. Spec-First Development (Non-Negotiable)

**Core Law**: All code MUST be generated by Claude Code following the strict Specify → Plan → Tasks → Implement workflow. Manual code commits are forbidden.

### Mandatory Rules

- **Zero Manual Coding**: No human-authored code. All implementation must be artifact-driven and generated by Claude Code tools.
- **Traceability in Every Line**: Every single line of generated code MUST include an inline comment referencing its Task ID and Spec section:
  - **Python Format**: `# [Task]: T-XXX, [From]: specs/[section]`
  - **TypeScript Format**: `// [Task]: T-XXX, [From]: specs/[section]`
  - **Example** (Python): `# [Task]: T-005, [From]: specs/authentication/spec.md#FR-001`
- **Workflow Sequence (Immutable)**: Specify → Plan → Tasks → Implement. No Task ID = No Code. Every task must have a corresponding specification section.
- **Single Source of Truth**: The spec document (`.md`) is the authoritative source. Code comments MUST reference it, not vice versa.

### Rationale

Spec-first development ensures full end-to-end traceability from business requirements to implementation. It prevents drift from specifications, enables atomic rollback of features by Task ID, and maintains a complete audit trail for the hackathon. Every line of code can be linked back to a requirement and tested independently.

---

## 2. Progressive Evolution Architecture

**Core Law**: Phase 2 is the second phase in a planned 5-phase evolution. Backward compatibility with Phase 1 must be maintained, and the architecture must accommodate future phases.

### Evolution Roadmap

1. **Phase 1**: Console application (completed, in production)
2. **Phase 2**: Web application with multi-user support, persistent storage, JWT authentication
3. **Phase 3**: AI Chatbot integration (planned)
4. **Phase 4**: Local Kubernetes orchestration (planned)
5. **Phase 5**: Cloud Kubernetes deployment (planned)

### Phase 2 Constraints

- **Backward Compatibility**: Existing console app data models and workflows must be compatible with web interface. Use migration strategies (if needed) to bridge Phase 1 → Phase 2.
- **Stateless Services**: Backend services must not depend on Phase 1 console state. All state is persisted in the database.
- **Modular Architecture**: Components must be designed for extraction to microservices (Phase 4+). Avoid monolithic coupling.
- **Database as Single Source of Truth**: Web app relies entirely on Neon PostgreSQL; no in-memory caches without invalidation strategy.

### Rationale

Progressive evolution ensures the application can scale from a console tool to a cloud-native system without rewrites. Maintaining compatibility reduces migration risk and enables smooth onboarding of Phase 2 features alongside Phase 1 users (if applicable).

---

## 3. Clean Architecture & Stateless Services

**Core Law**: Separate concerns explicitly across models, services, API, and infrastructure layers. Backend must be completely stateless.

### Architectural Layers

- **Models Layer** (`backend/src/models/`): Data entities (User, Task) with validation, no business logic.
- **Services Layer** (`backend/src/services/`): Business logic, query composition, state transitions. Depends only on models and database.
- **API Layer** (`backend/src/api/`): HTTP endpoints, authentication/authorization, request/response marshaling. Depends on services.
- **Infrastructure** (`helm/`, `backend/.env`): Database, authentication providers, deployment configuration. Configured, not hard-coded.

### Stateless Backend Guarantee

- **No Session State**: Backend MUST NOT store user sessions in memory. All state lives in Neon PostgreSQL.
- **No File System State**: Temp files, caches, or uploaded assets must be persisted to external storage (e.g., S3-compatible) or database, never local disk.
- **Horizontal Scalability**: Any instance must be able to handle any request independently. No instance affinity.
- **JWT as Identity Token**: User identity travels in the JWT; backend extracts it and scopes queries accordingly.

### Rationale

Stateless services enable horizontal scaling, simplify deployment to Kubernetes (Phase 4), and reduce operational complexity. Clear separation of concerns reduces bugs and enables independent testing of each layer.

---

## 4. Security-First Implementation

**Core Law**: JWT authentication with Better Auth, strict endpoint protection, user data isolation, and no plain-text secrets.

### Authentication & Authorization

- **JWT Handshake**: Better Auth (Frontend) and FastAPI (Backend) MUST share the `BETTER_AUTH_SECRET` environment variable.
  - Secret is injected at runtime via `.env` (dev) or platform environment (prod).
  - Secret is NEVER committed to version control.
  - Secret is NEVER logged or transmitted in plain text.
- **Stateless Verification**: Backend MUST verify JWT on every request:
  - Missing or malformed token → `401 Unauthorized`
  - Expired or invalid signature → `401 Unauthorized`
  - Valid token → extract `user_id` claim and scope all queries to that user.
- **Token Claims**: JWT MUST include:
  - `user_id`: UUID or primary key of authenticated user (required for data isolation)
  - `exp`: Expiration timestamp (required for token validity)
  - `iat`: Issued-at timestamp (required for token age validation)

### Data Isolation (CRITICAL)

- **User Scoping**: Every query (GET, POST, PUT, DELETE) MUST be scoped by the `user_id` extracted from JWT:
  - Request path `user_id` ≠ JWT `user_id` → `403 Forbidden` (Forbidden, not 404, to avoid leaking existence of other users' resources)
  - No cross-user data leakage; this is a hard constraint.
  - Example: `GET /api/users/{user_id}/tasks` MUST verify that `user_id` in path matches JWT `user_id`.
- **Query-Level Enforcement**: All database queries include a `WHERE user_id = :user_id` clause. No exceptions.

### Secret Management

- **No Plain-Text Secrets**: Passwords, API keys, and tokens MUST never be stored, logged, or transmitted in plain text.
  - Passwords: Use bcrypt (minimum) for hashing. Store hashed values only.
  - Tokens: Use JWT with HS256 (HMAC-SHA256) signed by `BETTER_AUTH_SECRET`.
  - API Keys: Encrypt in database or store in secure vault (e.g., AWS Secrets Manager).
- **Environment Isolation**: `.env` files are for local development only, never committed. Production uses platform-provided environment variables.

### Input Validation

- **Pydantic Models (Backend)**: All request bodies MUST be validated via Pydantic models. Invalid input → `400 Bad Request` with error details.
- **Strict TypeScript (Frontend)**: All API client types MUST use strict TypeScript (strict: true in tsconfig). No `any` types.

### Rationale

JWT-based stateless authentication enables horizontal scaling and simplifies deployment. User-scoped queries prevent authorization bypass and multi-tenancy data leaks. Cryptographic enforcement (bcrypt, HS256) ensures secrets are never exposed even if logs or database are compromised.

---

## 5. Test-Driven Development & Quality Gates

**Core Law**: Minimum 70% test coverage. Strict typing. All code must pass Ruff (Python) and ESLint (JavaScript/TypeScript) linting.

### Test Coverage Requirements

- **Minimum 70% Coverage**: Measured via `pytest --cov` (Python) and `vitest --coverage` (JavaScript/TypeScript).
  - Coverage includes unit, integration, and contract tests.
  - Pre-commit hooks block commits that fall below 70%.
- **Unit Tests**: Test individual functions/methods in isolation.
  - Database queries use fixtures with test database (e.g., test PostgreSQL instance).
  - Services are unit-tested with mocked dependencies.
- **Integration Tests**: Test end-to-end workflows (e.g., user creation → task creation → task completion).
  - Use real database instance for integration tests.
  - Test error paths and edge cases.
- **Contract Tests**: Test API endpoints (request/response schemas, status codes, error handling).
  - Backend contract tests verify API matches spec.
  - Frontend contract tests verify backend API is callable and returns expected shape.

### Strict Typing

- **Python Type Hints**: All functions MUST have type hints for parameters and return values.
  - Example: `def create_user(name: str, email: str) -> User:`
  - Use `mypy` for static type checking. Zero `Any` types without justification.
- **Strict TypeScript**: `tsconfig.json` MUST have `"strict": true`.
  - All variables, function parameters, and return types MUST be typed.
  - No `any` types. Use generics or union types instead.

### Linting & Code Quality

- **Ruff (Python)**: Zero tolerance for violations. Pre-commit hooks enforce.
  - Configuration: `pyproject.toml` [tool.ruff]
  - Check: `ruff check src/`
  - Format: `ruff format src/`
- **ESLint (JavaScript/TypeScript)**: Zero tolerance for violations. Pre-commit hooks enforce.
  - Configuration: `.eslintrc.json`
  - Check: `eslint src/`
  - Auto-fix where possible.

### Test Execution

- **Before Every Commit**: Run linting and tests locally.
- **Pre-commit Hooks**: Automatically run tests and linting; block commits that fail.
- **CI/CD Pipeline**: GitHub Actions (or similar) runs full test suite on every push to main/develop.

### Rationale

70% coverage ensures critical paths are tested and bugs are caught early. Strict typing reduces runtime errors and enables refactoring with confidence. Linting enforces consistency, readability, and catches common mistakes. Pre-commit hooks prevent bad code from entering the repository.

---

## 6. Monorepo Structure & Documentation Standards

**Core Law**: Strictly organized monorepo with `/frontend`, `/backend`, `/specs`, `/helm` folders. CLAUDE.md files guide Claude Code at each level.

### Directory Structure

```
/
├── .specify/                          # Spec-Kit Plus governance
│   ├── memory/
│   │   └── constitution.md            # This file (System Laws)
│   ├── templates/
│   │   ├── spec-template.md
│   │   ├── plan-template.md
│   │   ├── tasks-template.md
│   │   └── phr-template.prompt.md
│   └── scripts/
│       └── bash/
│           ├── create-spec.sh
│           ├── create-phr.sh
│           └── ...
├── CLAUDE.md                          # Root-level guidance for Claude Code
├── frontend/                          # Next.js 16+ Web App
│   ├── CLAUDE.md                      # Frontend-specific guidance
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   ├── services/                  # API client services
│   │   └── hooks/
│   ├── tests/
│   │   ├── unit/
│   │   ├── integration/
│   │   └── contract/
│   ├── package.json
│   ├── tsconfig.json                  # strict: true required
│   └── .eslintrc.json
├── backend/                           # FastAPI Python 3.13+ Service
│   ├── CLAUDE.md                      # Backend-specific guidance
│   ├── src/
│   │   ├── models/
│   │   ├── services/
│   │   ├── api/
│   │   └── main.py                    # FastAPI app entry
│   ├── tests/
│   │   ├── unit/
│   │   ├── integration/
│   │   └── contract/
│   ├── pyproject.toml
│   ├── .env.example                   # Never commit .env
│   └── requirements.txt
├── specs/                             # Feature specifications
│   ├── authentication/
│   │   ├── spec.md
│   │   ├── plan.md
│   │   └── tasks.md
│   ├── task-management/
│   │   ├── spec.md
│   │   ├── plan.md
│   │   └── tasks.md
│   └── ...
├── specs-history/                     # Version history of specs
│   ├── authentication/
│   │   ├── spec-v1.0.0.md
│   │   └── spec-v1.1.0.md
│   └── ...
├── helm/                              # Infrastructure & Deployment
│   ├── values.yaml
│   ├── templates/
│   │   ├── deployment.yaml
│   │   └── service.yaml
│   └── ...
└── history/
    └── prompts/                       # Prompt History Records
        ├── constitution/
        ├── authentication/
        ├── task-management/
        └── general/
```

### CLAUDE.md Files (Guardians of Local Context)

Each service must have a `CLAUDE.md` file that guides Claude Code:

- **Root CLAUDE.md**: Monorepo-wide rules (Spec-First, naming conventions, module structure).
- **Frontend CLAUDE.md**: Next.js-specific guidance (App Router patterns, component structure, styling with Tailwind, API client patterns).
- **Backend CLAUDE.md**: FastAPI-specific guidance (endpoint structure, Pydantic models, SQLModel ORM patterns, error handling).

### Spec File Organization

- **One Feature per Directory**: `/specs/<feature-name>/`
- **Three Core Files per Feature**:
  1. `spec.md`: Feature requirements, user stories, acceptance criteria
  2. `plan.md`: Architecture decisions, technical approach, data models
  3. `tasks.md`: Testable atomic units of work with Task IDs (T-XXX)
- **Version Control**: Every spec iteration is tracked in `/specs-history/<feature>/<filename>-v<X.Y.Z>.md`
- **Naming Conventions**:
  - Feature directories use kebab-case: `task-management`, `user-authentication`, `ai-chatbot`
  - Spec files are lowercase: `spec.md`, `plan.md`, `tasks.md`

### Documentation Standards

- **Markdown Format**: All specifications and planning documents use GitHub Flavored Markdown (GFM).
- **Headings Hierarchy**: H1 for title, H2 for major sections, H3 for subsections. No skipped levels.
- **Code Blocks**: Use triple backticks with language identifier (python, typescript, sql, etc.).
- **Tables**: Use GFM table syntax for data structures, endpoints, and comparisons.
- **Comments in Specs**: Use HTML comments `<!-- -->` for editorial notes, action items, or clarifications.

### Rationale

Strictly organized monorepo reduces confusion, enables parallel work on frontend/backend/specs, and simplifies deployment. CLAUDE.md files ensure Claude Code respects service-specific constraints and patterns. Spec versioning in `/specs-history/` maintains audit trail and enables rollback. Clear documentation standards ensure specs are understandable and enforceable.

---

## 7. Feature Requirements & Constraints

**Core Law**: Phase 2 must implement all Basic Level task CRUD and completion features with the specified technology stack.

### Feature Scope (Phase 2 MVP)

- **User Authentication**: Sign up, log in, log out with Better Auth + JWT
- **Task Management**: Create, Read, Update, Delete (CRUD) tasks
- **Task Completion**: Mark tasks as complete/incomplete
- **User Data Isolation**: Users only see and modify their own tasks
- **Persistent Storage**: All data persists in Neon PostgreSQL
- **Multi-User Support**: Multiple concurrent users, independently isolated

### Technology Stack (Immutable for Phase 2)

| Layer | Technology | Rationale |
|-------|-----------|-----------|
| Frontend Framework | Next.js 16+ (App Router) | Modern React with server components, built-in optimization |
| Frontend Language | Strict TypeScript | Type safety at the boundary |
| Frontend Styling | Tailwind CSS | Utility-first, rapid UI development |
| Frontend Testing | Vitest, React Testing Library | Fast unit tests, realistic component testing |
| Backend Framework | FastAPI (Python 3.13+) | Modern, fast, async-native, built-in OpenAPI |
| Backend Language | Python 3.13+ | Type hints required, strict linting |
| Backend Testing | pytest, pytest-cov | Industry standard, excellent coverage reporting |
| ORM | SQLModel | Combines Pydantic (validation) + SQLAlchemy (queries) |
| Database | Neon PostgreSQL | Managed, serverless, scales with demand |
| Authentication | Better Auth | JWT-native, multi-provider support, production-ready |
| JWT Algorithm | HS256 (HMAC-SHA256) | Symmetric signing with `BETTER_AUTH_SECRET` |
| Package Management | UV (Python), pnpm (JavaScript) | Fast, deterministic, modern lock files |
| Deployment Frontend | Vercel | Seamless Next.js integration, automatic deploys |
| Deployment Backend | Railway or Render | Python support, managed databases, webhooks |
| Linting | Ruff (Python), ESLint (JS/TS) | Fast, zero-config, strict enforcement |

### Endpoint Security

- **All API endpoints** under `/api` MUST require valid JWT in `Authorization: Bearer <token>` header.
- **Exception**: `POST /api/auth/signup` and `POST /api/auth/login` (authentication endpoints themselves) do not require JWT.
- **Invalid token response**: `401 Unauthorized` with message "Invalid or expired token".

### Data Isolation

- **Core Principle**: Users can ONLY read/write their own tasks.
- **Enforcement**: Every query includes `WHERE user_id = :current_user_id` derived from JWT.
- **Example Query** (backend):
  ```python
  # backend/src/services/task_service.py
  # [Task]: T-012, [From]: specs/task-management/spec.md#FR-002
  async def get_user_tasks(user_id: str, db: Session) -> List[Task]:
      return db.query(Task).filter(Task.user_id == user_id).all()
  ```

### Rationale

These constraints ensure Phase 2 delivers a secure, multi-user web application while maintaining compatibility with Phase 1 and laying groundwork for Phases 3-5 (AI, Kubernetes, cloud). The technology stack is chosen for maintainability, scalability, and hackathon feasibility.

---

## 8. API Conventions

**Core Law**: All endpoints live under `/api` prefix. RESTful design with JSON request/response format.

### Endpoint Structure

```
POST   /api/auth/signup            # Register new user
POST   /api/auth/login             # Authenticate and return JWT
POST   /api/auth/logout            # Invalidate session (if applicable)

GET    /api/users/{user_id}/tasks  # List user's tasks
POST   /api/users/{user_id}/tasks  # Create new task for user
GET    /api/users/{user_id}/tasks/{task_id}  # Get specific task
PUT    /api/users/{user_id}/tasks/{task_id}  # Update task
DELETE /api/users/{user_id}/tasks/{task_id}  # Delete task

PATCH  /api/users/{user_id}/tasks/{task_id}/complete  # Mark task complete
PATCH  /api/users/{user_id}/tasks/{task_id}/incomplete # Mark task incomplete
```

### Request Format

All request bodies are JSON:

```json
{
  "title": "Buy groceries",
  "description": "Milk, eggs, bread",
  "priority": "high"
}
```

### Response Format (Success)

All successful responses follow this structure:

```json
{
  "success": true,
  "data": { /* entity */ },
  "message": "Task created successfully"
}
```

### Response Format (Error)

All error responses follow this structure:

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message",
    "details": {}
  },
  "status": 400
}
```

### Status Codes

| Code | Meaning | Example |
|------|---------|---------|
| 200 | OK | Task retrieved successfully |
| 201 | Created | New task created |
| 204 | No Content | Task deleted successfully |
| 400 | Bad Request | Invalid JSON, missing required field |
| 401 | Unauthorized | Missing or invalid JWT token |
| 403 | Forbidden | Attempting to access another user's task |
| 404 | Not Found | Task does not exist (only return after verifying user isolation) |
| 500 | Internal Server Error | Unexpected backend error |

### Error Codes (Backend)

Define custom error codes for different failure modes:

- `AUTH_INVALID_CREDENTIALS`: Login failed (wrong password)
- `AUTH_USER_EXISTS`: User already registered
- `AUTH_MISSING_TOKEN`: Authorization header missing
- `AUTH_INVALID_TOKEN`: JWT signature invalid or expired
- `TASK_NOT_FOUND`: Task does not exist
- `TASK_VALIDATION_FAILED`: Task validation failed (e.g., empty title)
- `USER_NOT_FOUND`: User does not exist
- `FORBIDDEN_USER_MISMATCH`: Attempting to access another user's resource

### Documentation Requirement

Each endpoint MUST be documented in `specs/<feature>/contracts/` directory with:
- Request schema (Pydantic model or JSON Schema)
- Response schema
- Status codes and error codes
- Example request/response
- Authentication requirement

### Rationale

Consistent API conventions reduce client-side errors, simplify frontend integration, and enable automatic API documentation (via FastAPI's OpenAPI support). Standard status codes and error codes make debugging easier. JSON request/response format is language-agnostic and widely supported.

---

## 9. Database Conventions

**Core Law**: SQLModel ORM with Neon PostgreSQL. Strict foreign keys, required indexes, user-scoped queries.

### Schema Design

```python
# backend/src/models/user.py
# [Task]: T-003, [From]: specs/authentication/spec.md#FR-001
from sqlmodel import SQLModel, Field
from typing import Optional
import uuid

class User(SQLModel, table=True):
    """User account entity."""
    __tablename__ = "users"

    id: str = Field(default_factory=lambda: str(uuid.uuid4()), primary_key=True)
    email: str = Field(unique=True, index=True)
    password_hash: str  # bcrypt hash, NEVER plain text
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)


# backend/src/models/task.py
# [Task]: T-004, [From]: specs/task-management/spec.md#FR-002
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    """Task entity, always scoped to a user."""
    __tablename__ = "tasks"

    id: str = Field(default_factory=lambda: str(uuid.uuid4()), primary_key=True)
    user_id: str = Field(foreign_key="users.id", ondelete="CASCADE", index=True)
    title: str = Field(min_length=1, max_length=255)
    description: Optional[str] = None
    completed: bool = Field(default=False, index=True)
    priority: str = Field(default="normal")  # "low", "normal", "high"
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### Indexes

**Required Indexes**:
- `tasks.user_id`: Fast filtering by user (every query includes this)
- `tasks.completed`: Fast filtering of incomplete tasks (common query)
- `users.email`: Fast lookup by email (authentication)

Indexes are defined in the SQLModel class via `Field(index=True)`.

### Relationships

- **Foreign Keys**: `Task.user_id` → `User.id` with `OnDelete="CASCADE"` (delete user deletes all their tasks)
- **No Orphans**: Enforced at database level via foreign key constraints
- **Query Scoping**: All task queries include `WHERE user_id = :user_id` clause

### Migrations

- Use Alembic (SQLAlchemy migration tool) for schema changes
- Migration files in `backend/alembic/versions/`
- Every migration is versioned and can be rolled back
- Never modify existing migrations; create new ones for changes

### Data Types

| Concept | Type | Notes |
|---------|------|-------|
| User ID | UUID (string) | Use `uuid.uuid4()` for generation |
| Email | VARCHAR(255) | Unique index, case-insensitive queries |
| Password | VARCHAR(255) | Store bcrypt hash, minimum 60 characters for bcrypt |
| Title | VARCHAR(255) | Non-null, min 1 char, max 255 chars |
| Timestamps | DATETIME | UTC, auto-set on create/update |
| Boolean | BOOLEAN | For `completed`, `is_active`, etc. |

### Rationale

SQLModel combines Pydantic validation (frontend-like type safety) with SQLAlchemy ORM (powerful queries). Neon PostgreSQL provides managed, serverless scalability. Required indexes ensure fast queries at any user count. Foreign keys with CASCADE prevent orphaned data. UUID primary keys enable distributed generation without database round-trips.

---

## 10. Workflow Enforcement

**Core Law**: No code without a Task ID. No Task ID without a Spec section. Single source of truth is the specification.

### The Spec-First Workflow (Immutable Sequence)

1. **Specify**: Write user stories and requirements in `specs/<feature>/spec.md`
   - User stories describe **what** users can do
   - Requirements specify **constraints** and **rules**
   - Run `/sp.specify` to generate from natural language input
2. **Plan**: Design technical approach in `specs/<feature>/plan.md`
   - Architectural decisions (technology, patterns, data models)
   - Trade-offs and rationale
   - Data model sketches
   - Run `/sp.plan` to generate from spec
3. **Tasks**: Break down into atomic work items in `specs/<feature>/tasks.md`
   - Each task has a unique ID (T-001, T-002, etc.)
   - Each task references a Spec section and User Story
   - Tasks can be parallelized (marked with [P])
   - Run `/sp.tasks` to generate from plan
4. **Implement**: Generate code for each task
   - Task ID MUST be referenced in code comments
   - Code MUST reference the Spec section
   - Run `/sp.implement` to execute tasks (or use other Claude Code tools per task)

### Code Comment Traceability

Every line of code MUST link back to a task and spec:

**Python Example**:
```python
# [Task]: T-005, [From]: specs/authentication/spec.md#FR-001
async def create_user(email: str, password: str) -> User:
    password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())
    user = User(email=email, password_hash=password_hash)
    # [Task]: T-005, [From]: specs/authentication/spec.md#FR-002
    db.add(user)
    db.commit()
    return user
```

**TypeScript Example**:
```typescript
// [Task]: T-010, [From]: specs/task-management/spec.md#FR-003
export async function createTask(userId: string, title: string): Promise<Task> {
  const response = await fetch(`/api/users/${userId}/tasks`, {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${getToken()}` },
    // [Task]: T-010, [From]: specs/task-management/spec.md#FR-004
    body: JSON.stringify({ title })
  });
  return response.json();
}
```

### Violation Prevention

- **Pre-commit Hooks**: Block commits where code lacks Task ID comments (search for `\[Task\]` pattern)
- **Code Review**: Every PR must show which Tasks are being addressed
- **Task Tracking**: Use `/sp.tasks` to generate tasks before implementing

### Single Source of Truth

- **Source**: `/specs/<feature>/spec.md` is the authority on **what** to build
- **Design**: `/specs/<feature>/plan.md` documents **how** to build it
- **Work**: `/specs/<feature>/tasks.md` lists **where** to build
- **Code**: Comments reference spec sections, never contradict spec

### Rationale

Traceability prevents drift from requirements, enables feature rollback by Task ID, and maintains a complete audit trail. Pre-commit hooks catch violations early. Single source of truth prevents conflicting guidance and reduces confusion.

---

## 11. External Context Integration

**Core Law**: Claude Code MUST use the **context7 MCP server** to fetch latest documentation for all framework dependencies.

### When to Use context7

- **Framework Documentation**: Next.js 16, FastAPI, SQLModel, Better Auth, Neon PostgreSQL
- **Library APIs**: Pydantic, bcrypt, pytest, Vitest, Tailwind CSS
- **Integration Patterns**: How to combine Better Auth with FastAPI, Next.js with Tailwind, etc.
- **Breaking Changes**: Check for version-specific breaking changes or migration guides
- **Best Practices**: Fetch current security recommendations, performance tuning, etc.

### How to Invoke context7

Use the `mcp__context7__query-docs` MCP tool via Claude Code:

```
Query: "How to verify JWT tokens in FastAPI with custom claims?"
Library ID: "/fastapi/docs" or "/better-auth/docs"
```

Claude Code will fetch the latest documentation and return relevant examples.

### Documenting External Context

Every code snippet or pattern fetched from external documentation MUST be documented:

```python
# [Task]: T-008, [From]: specs/authentication/spec.md#FR-005
# External Context: Verified against FastAPI docs (context7 fetch)
# Pattern: https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/
from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer

async def verify_jwt(credentials: HTTPBearer = Depends(HTTPBearer())):
    token = credentials.credentials
    try:
        payload = jwt.decode(token, BETTER_AUTH_SECRET, algorithms=["HS256"])
        user_id = payload.get("user_id")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")
    return user_id
```

### Rationale

Context7 MCP provides real-time access to framework documentation, reducing hallucination risk and ensuring generated code aligns with framework authors' current best practices. Documenting external context sources makes generated code verifiable and maintainable.

---

## 12. Quality Standards & Deliverables Checklist

**Core Law**: Phase 2 must deliver frontend UI, backend API, spec files, and CLAUDE.md guidance.

### Frontend Deliverables

- [ ] **Components**: Reusable UI components (Button, Input, Card, etc.) in `frontend/src/components/`
- [ ] **Pages**: Full pages implementing task management and authentication flows in `frontend/src/pages/`
- [ ] **Services**: API client service layer in `frontend/src/services/api.ts` (handles JWT, error handling, retries)
- [ ] **Hooks**: Custom React hooks for auth state, task queries, etc. in `frontend/src/hooks/`
- [ ] **Tests**: Unit tests for components, integration tests for workflows in `frontend/tests/`
- [ ] **Styling**: Tailwind CSS configured, all components styled, responsive design
- [ ] **TypeScript Strict**: `tsconfig.json` with `"strict": true`, zero `any` types
- [ ] **Linting**: All code passes ESLint, no warnings
- [ ] **Coverage**: Minimum 70% test coverage, verified with `vitest --coverage`

### Backend Deliverables

- [ ] **Models**: User and Task entities in `backend/src/models/` with SQLModel
- [ ] **Services**: Business logic in `backend/src/services/` (no DB queries in endpoints)
- [ ] **API Endpoints**: RESTful endpoints in `backend/src/api/` with JWT verification
- [ ] **Database**: Neon PostgreSQL schema with migrations
- [ ] **Error Handling**: Consistent error responses, proper status codes, error codes
- [ ] **Tests**: Unit, integration, and contract tests in `backend/tests/`
- [ ] **Type Hints**: All functions typed, `mypy` passes without errors
- [ ] **Linting**: All code passes Ruff, no violations
- [ ] **Coverage**: Minimum 70% test coverage, verified with `pytest --cov`
- [ ] **Logging**: Structured logging for debugging, no secrets logged

### Specification Deliverables

- [ ] **Feature Spec**: `specs/authentication/spec.md` with user stories and requirements
- [ ] **Feature Spec**: `specs/task-management/spec.md` with user stories and requirements
- [ ] **Plan**: `specs/authentication/plan.md` with technical approach
- [ ] **Plan**: `specs/task-management/plan.md` with technical approach
- [ ] **Tasks**: `specs/authentication/tasks.md` with Task IDs, dependencies, checklist
- [ ] **Tasks**: `specs/task-management/tasks.md` with Task IDs, dependencies, checklist
- [ ] **Contracts**: `specs/*/contracts/` directory with API endpoint documentation

### Documentation Deliverables

- [ ] **Root CLAUDE.md**: Monorepo-wide rules and conventions
- [ ] **Frontend CLAUDE.md**: Next.js patterns, component structure, styling guidelines
- [ ] **Backend CLAUDE.md**: FastAPI patterns, model structure, API conventions
- [ ] **README.md**: Project overview, how to run, deployment instructions
- [ ] **Quickstart.md**: Step-by-step guide for new developers (frontend + backend setup)
- [ ] **ADR Directory**: `history/adr/` with Architecture Decision Records for major decisions

### Quality Gates (Pre-Release)

- [ ] All tests pass (`pytest` + `vitest`)
- [ ] Test coverage ≥ 70% (both backend and frontend)
- [ ] All code passes linting (`ruff` + `eslint`)
- [ ] All code has Task ID comments referencing spec sections
- [ ] No plain-text secrets in code or logs
- [ ] JWT verification working end-to-end (frontend → backend)
- [ ] User data isolation verified (cannot access other users' tasks)
- [ ] All endpoints documented with request/response schemas
- [ ] Database migrations tested and reversible
- [ ] Error handling tested for all error paths

### Rationale

Comprehensive deliverables ensure Phase 2 is production-ready, well-documented, and maintainable. Quality gates catch issues before release and ensure compliance with constitution principles.

---

## Governance & Compliance

### Amendment Procedure

1. **Identify Need**: A change to this constitution is needed (new principle, clarification, removal)
2. **Propose**: Draft the amendment with rationale
3. **Ratify**: Adopt the amendment with a new version number (semantic versioning)
4. **Propagate**: Update dependent artifacts (spec/plan/task templates, CLAUDE.md files, etc.)
5. **Record**: Add amendment to Sync Impact Report with date and version bump

### Versioning Policy

- **MAJOR** (X.0.0): Backward-incompatible changes (principle removal, redefinition)
- **MINOR** (1.Y.0): New principles or sections added, expanded guidance
- **PATCH** (1.0.Z): Clarifications, wording, non-semantic refinements

### Compliance Review

Before any release, verify:

1. **Traceability**: All code has Task ID comments referencing spec sections
2. **Testing**: Test coverage ≥ 70%, all tests passing
3. **Linting**: Zero linting violations (Ruff, ESLint, mypy)
4. **Security**: No plain-text secrets, JWT verification working, user isolation enforced
5. **Documentation**: All endpoints documented, specs complete, CLAUDE.md guides present
6. **Specs**: All code has corresponding Task in `tasks.md`

### Enforcement

- **Pre-commit Hooks**: Block commits with missing Task IDs, linting violations, or test failures
- **Code Review**: Every PR verified against compliance checklist
- **Automated Testing**: CI/CD pipeline runs full test suite and linting on every push
- **Architecture Review**: ADRs created for major decisions; reviewed for alignment with constitution

---

## Appendix: Spec File Organization (Phase 2)

### Feature: Authentication

**Location**: `/specs/authentication/`

**Files**:
- `spec.md`: User registration, login, session management
- `plan.md`: JWT architecture, Better Auth integration, token lifecycle
- `tasks.md`: Backend JWT middleware, frontend auth hooks, integration tests

### Feature: Task Management

**Location**: `/specs/task-management/`

**Files**:
- `spec.md`: Task CRUD, completion status, user isolation
- `plan.md`: SQLModel schema, service layer design, error handling
- `tasks.md`: Models, CRUD endpoints, frontend UI, tests

### Feature: (Future) AI Chatbot

**Location**: `/specs/ai-chatbot/` (Phase 3)

**Files**: (To be created in Phase 3)

---

## Summary

This constitution establishes 12 non-negotiable principles for Evolution of Todo Phase 2:

1. **Spec-First Development**: No manual code; all generated via Specify → Plan → Tasks → Implement
2. **Progressive Evolution**: Phase 2 of 5-phase evolution; backward compatible
3. **Clean Architecture**: Separated layers; stateless backend; single source of truth
4. **Security-First**: JWT + Better Auth, user-scoped queries, no plain-text secrets
5. **Test-Driven**: 70% coverage, strict typing, zero linting violations
6. **Monorepo Structure**: Frontend, backend, specs, helm with CLAUDE.md guardians
7. **Feature Requirements**: Task CRUD, multi-user, JWT auth, Neon PostgreSQL
8. **API Conventions**: RESTful `/api` endpoints, JSON request/response, standard status codes
9. **Database Conventions**: SQLModel, required indexes, user-scoped queries
10. **Workflow Enforcement**: Task ID traceability, spec-first workflow, single source of truth
11. **External Context**: context7 MCP for framework documentation
12. **Quality Standards**: Comprehensive deliverables checklist, pre-release quality gates

All governance is hierarchical: **Constitution > Spec > Plan > Tasks > Code**. Amendments are tracked with semantic versioning. Compliance is enforced via pre-commit hooks, code review, and CI/CD automation.

**Next Steps**: Use `/sp.specify` to create feature specs for authentication and task management aligned with this constitution.

---

**Ratified by**: Claude Code (Spec-Driven Development Agent)
**Ratification Date**: 2026-02-01
**Next Review Date**: Upon completion of Phase 2 MVP (all deliverables checklist items ✅)

---

# Phase-III Constitution: AI Todo Chatbot (NEW)

**Project**: Evolution of Todo Phase 3 (AI-Powered Conversational Interface)
**Scope**: Intelligent chatbot layer on top of existing Phase-II full-stack application
**Version**: 3.0.0 (introduced)
**Added**: 2026-02-07

---

## Phase-III Overview

The Phase-III AI Todo Chatbot is **NOT** a new application. It is an intelligent conversational interface that leverages the existing Phase-II backend, database, and authentication system.

### Architecture Principle
- Chatbot is a **frontend layer** (Next.js UI + floating widget) that wraps Phase-II APIs
- All task persistence, user management, and data storage remains in Phase-II (Neon PostgreSQL)
- AI reasoning and tool invocation via **OpenAI Agents SDK** with **MCP tools**
- No parallel backend, no duplicate logic, no direct database access by AI

---

## P3.1: Full-Stack Integration Only

**Core Law**: Chatbot must reuse Phase-II backend, database, authentication, and task models. No parallel systems.

### Requirements
- **No Duplicate Logic**: Use existing Phase-II task CRUD endpoints (`/api/users/{user_id}/tasks`)
- **Shared Database**: Store conversation history in new `conversations` and `messages` tables (Neon PostgreSQL)
- **JWT Reuse**: Same authentication context as Phase-II; every chat request includes JWT token
- **User Isolation**: Chatbot enforces same user_id scoping as Phase-II (no cross-user data)
- **No AI Database Access**: AI agents ONLY interact via MCP tools; never direct database queries

### Enforcement
- Code review checklist: Verify no new task services created; chatbot uses existing endpoints
- Architecture review: Confirm AI does not bypass Phase-II APIs or authentication

### Rationale
Full-stack integration ensures single source of truth for task data, reduces maintenance burden, and leverages Phase-II investments. Prevents data inconsistency between UI and chatbot.

---

## P3.2: OpenAI-Only AI Stack

**Core Law**: OpenAI API and Agents SDK are the ONLY AI credentials and services. No Gemini, Claude, Grok, or alternatives.

### Requirements
- **OpenAI API Key**: Single credential in `.env` for OpenAI API access
- **OpenAI Agents SDK**: Use `openai-agents` Python library for agent orchestration
- **OpenAI Models**: Only GPT-4, GPT-4-turbo, GPT-4o, or newer OpenAI models
- **No Alternative AI**: Strictly forbidden: Google Gemini, Anthropic Claude, X.com Grok, or any other LLM provider
- **Configuration**: API key stored in environment, never hardcoded

### Token Budget
- Monitor OpenAI API usage; set spending limits and alerts in OpenAI dashboard
- Log all API calls for auditing and cost tracking

### Rationale
Single vendor eliminates dependency complexity, simplifies billing, ensures consistent behavior, and aligns with hackathon constraints.

---

## P3.3: MCP-First Tool Architecture

**Core Law**: AI must interact with system ONLY via stateless MCP tools. No in-memory state. Tool invocation only after user confirmation.

### MCP Server
- **Framework**: FastAPI with MCP SDK (official Model Context Protocol implementation)
- **Stateless Design**: No in-memory conversation state; every request fully independent
- **Database-Backed**: Query state from Neon PostgreSQL on each request
- **User Context**: Every tool receives `user_id` from JWT token; enforces user isolation

### Tool Definitions
Expose 5 core task tools via MCP:

| Tool | Purpose | Parameters | Returns |
|------|---------|-----------|---------|
| `add_task` | Create new task | title (req), description, priority, tags | task object |
| `list_tasks` | Fetch user's tasks | filters, limit, offset | task array |
| `update_task` | Modify task | task_id, title/description/priority | updated task |
| `complete_task` | Mark task done | task_id | task object |
| `delete_task` | Remove task | task_id | confirmation |

### Tool Invocation Policy
- **Intent Detection**: AI detects user intent (add/list/update/complete/delete) but does NOT invoke without confirmation
- **Confirmation Required**: AI MUST ask user before executing any tool call
  - Exception: READ-ONLY operations (list) may execute without confirmation if context clear
  - Destructive: DELETE always requires explicit confirmation ("Are you sure?")
- **Error Handling**: Tool errors (task not found, validation failed) return friendly messages; AI suggests recovery

### Tool Chaining
- AI may compose multiple tool calls sequentially (e.g., "list incomplete tasks, then create a new task")
- Each composed call appears in conversation history; user confirms multi-step workflows

### Rationale
MCP ensures AI cannot bypass authentication, directly modify database, or access unauthorized data. Statelessness enables horizontal scaling and server restarts without conversation loss.

---

## P3.4: Conversational Safety Rules

**Core Law**: Intent detection ≠ execution. AI must collect structured data step-by-step and confirm before action.

### Data Collection Protocol
Before ANY tool invocation, AI must collect and validate:

#### For Task Creation
- **Title** (required): Clear, non-empty task name
  - If missing: "What would you like to create? Give it a title."
- **Description** (optional): Detailed context
- **Priority** (optional): User selects "High", "Medium", "Low" (with guidance)
- **Due Date** (optional): Natural language parsing ("tomorrow", "next Friday")
- **Tags** (optional): Comma-separated categories

#### For Task Update
- **Task Identification**: "Which task? I found: [list recent tasks]" if ambiguous
- **Field to Update**: Confirm which attribute (title, priority, description)
- **New Value**: Validate non-empty

#### For Destructive Actions
- **Task Confirmation**: "You're about to DELETE: [task name]. Are you sure? (yes/no)"
- **No Auto-Delete**: Never delete without explicit "yes" or "confirm"

### Conversation Examples

**GOOD: Step-by-step confirmation**
```
User: "I need to buy groceries"
AI: "I'll create a task: 'Buy groceries'. Priority: Medium. Description: (none). Confirm? (yes/no)"
User: "Yes"
AI: [invokes add_task] "✅ Created: Buy groceries"
```

**BAD: Auto-execution without confirmation**
```
User: "Delete my done tasks"
AI: [immediately deletes all completed tasks]
❌ NOT ALLOWED
```

**GOOD: Ambiguity clarification**
```
User: "Mark the first task complete"
AI: "I found multiple incomplete tasks. Did you mean: (1) Buy milk (2) Call mom (3) Code review?"
User: "(1)"
AI: [invokes complete_task] "✅ Completed: Buy milk"
```

### Intent + Execution Separation
- **Phase 1 (Intent)**: AI interprets user input, detects intent
- **Phase 2 (Clarification)**: AI asks clarifying questions if needed
- **Phase 3 (Confirmation)**: AI shows action and asks user confirmation
- **Phase 4 (Execution)**: Only AFTER confirmation, AI invokes tool
- **Phase 5 (Feedback)**: AI shows result and asks "Anything else?"

### Rationale
Step-by-step data collection prevents accidental actions, reduces user frustration, and ensures accuracy. Explicit confirmation prevents AI hallucinations or misinterpretations from causing damage.

---

## P3.5: Stateless Backend, Persistent Conversation Memory

**Core Law**: Backend endpoints remain stateless. Conversation history persists in database. Messages survive server restart.

### Backend Statelessness
- **No In-Memory Conversation**: Backend does NOT cache conversation state
- **No WebSocket Persistence**: Chat does not rely on persistent WebSocket connections
- **No Session Objects**: User context extracted from JWT on each request; not stored in server memory
- **Database as Source of Truth**: Every chat message persists to `messages` table immediately

### Conversation Persistence
- **Conversations Table**:
  - `id` (UUID primary key)
  - `user_id` (foreign key → users.id)
  - `title` (conversation name, e.g., "Tuesday Planning")
  - `created_at`, `updated_at` timestamps
- **Messages Table**:
  - `id`, `conversation_id` (foreign key), `user_id` (foreign key)
  - `role` ("user", "assistant")
  - `content` (message text)
  - `created_at` timestamp
  - `metadata` (optional: tool_call_id, tool_name for tracking)

### Resumption Across Client Refresh
1. User refreshes browser or closes chat
2. Frontend requests: `GET /api/v1/conversations/{conversation_id}`
3. Backend returns conversation metadata + last N messages
4. Frontend reconstructs chat UI from message history
5. User can continue typing; context restored from database

### Server Restart Scenario
1. Server crashes or is restarted
2. Conversation history remains in Neon PostgreSQL (unaffected)
3. User session maintains conversation_id (in localStorage or cookie)
4. On reconnect, full message history loaded from database
5. Conversation seamlessly resumes

### Indexing for Performance
- `idx_user_conversations`: `(user_id, created_at DESC)` for fast conversation list
- `idx_conversation_messages`: `(conversation_id, created_at ASC)` for chronological retrieval
- `idx_user_messages`: `(user_id, created_at DESC)` for user's all messages

### Rationale
Stateless backend enables horizontal scaling and easy deployments. Database persistence ensures no data loss. Resumability across refresh and restart is critical UX requirement for chatbot reliability.

---

## P3.6: Secure User Context in Chat

**Core Law**: Every chat request requires JWT. `user_id` injected into agent context. AI never accesses another user's data.

### JWT in Chat Requests
- **Header**: `Authorization: Bearer <JWT_TOKEN>`
- **Validation**: Backend verifies token signature using `BETTER_AUTH_SECRET` (shared with Phase-II)
- **Invalid Token**: Return 401 Unauthorized; frontend redirects to login
- **Expired Token**: Return 401; frontend triggers token refresh or re-login

### User Context Injection
- **Token Decoding**: Extract `user_id` claim from JWT
- **Agent Context**: Pass `user_id` to OpenAI Agents SDK
- **Tool Parameter**: Every tool call receives `user_id` for scope enforcement
- **Query Scoping**: All database queries include `WHERE user_id = :user_id`

### Cross-User Access Prevention
- **Enforcement**: If user A tries to access user B's conversation (via URL or API):
  - Check: `conversation.user_id == jwt.user_id`
  - If mismatch: Return 403 Forbidden (not 404, to avoid leaking existence)
  - Log attempted breach for security audit
- **Tool Isolation**: Tools filter results by `user_id`; never return data from other users
- **Message Isolation**: Only show messages from authenticated user's conversations

### Rationale
JWT-based user context prevents authorization bypass and multi-tenancy data leaks. Consistent with Phase-II security principles.

---

## P3.7: Embedded Chat UI (No New Routes)

**Core Law**: Chatbot embedded into existing Phase-II frontend. No new pages, no new routes. Floating widget only.

### UI Integration
- **Chatbot Component**: `frontend/src/components/ChatKit.tsx` (Client Component)
  - Uses OpenAI ChatKit library or custom React component
  - Rendered in root layout (`app/[locale]/layout.tsx`)
  - Does NOT create new pages or routes
  - Placed OUTSIDE main content area (no interference with existing UI)

### Floating Widget Specifications
- **Position**: Bottom-right corner, fixed to viewport
- **Icon**: Clean, modern chat-bubble icon (SVG or emoji)
- **Animation**: Smooth open/close, slide-in from bottom-right
- **Visibility**: Only visible to authenticated users
  - Check: `if (session && session.user) { show ChatWidget }`
  - Unauthenticated: Widget hidden entirely
- **Z-Index**: High (e.g., 9999) but below modals
- **Mobile Responsive**: Scale appropriately on mobile; full-screen on small screens

### Chat Window Styling
- **Modern AI Look**: Soft colors, rounded corners, glass-morphism effect
- **Professional Tone**: Light/dark theme matching existing app design
- **Accessibility**: Keyboard navigation, focus management, screen reader support
- **No Distraction**: Does not interrupt primary app workflows; user can close and resume work

### Lazy Loading
- Widget loads only after user interaction (click icon) or after short delay
- Reduces initial page load impact
- API calls to chatbot endpoint made asynchronously

### Rationale
Non-invasive embedding ensures chatbot enhances existing UI without disrupting Phase-II user experience. Users retain full control (can close widget, continue using app normally).

---

## P3.8: Phase-III Database Extensions

**Core Law**: Only `conversations` and `messages` tables are added. Phase-II tables (`users`, `tasks`) remain unmodified.

### New Tables

#### conversations
```sql
CREATE TABLE conversations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  title VARCHAR(255) NOT NULL,
  description TEXT,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  deleted_at TIMESTAMP NULL,

  INDEX idx_user_conversations (user_id, created_at DESC),
  INDEX idx_updated (user_id, updated_at DESC)
);
```

#### messages
```sql
CREATE TABLE messages (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  conversation_id UUID NOT NULL REFERENCES conversations(id) ON DELETE CASCADE,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
  content TEXT NOT NULL,
  created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  metadata JSONB NULL,

  INDEX idx_conversation_messages (conversation_id, created_at ASC),
  INDEX idx_user_messages (user_id, created_at DESC)
);
```

### Phase-II Tables (UNCHANGED)
- `users`: No changes; existing authentication structure preserved
- `tasks`: No changes; existing task model preserved
- All Phase-II queries continue to work without modification

### Foreign Key Relationships
- `conversations.user_id` → `users.id` (cascade delete)
- `messages.user_id` → `users.id` (cascade delete)
- `messages.conversation_id` → `conversations.id` (cascade delete)
- Soft delete supported via `deleted_at` timestamp

### SQLModel Definitions
Conversation and Message models created in `backend/src/models/` following Phase-II patterns:
- Type hints, Pydantic validation
- Timestamps (created_at, updated_at)
- Proper indexing via Field(index=True)

### Rationale
Minimal, focused database extension keeps Phase-II unchanged while enabling conversation persistence. Soft deletes preserve audit trail. Proper indexing ensures fast queries at scale.

---

## P3.9: OpenAI Agents Integration

**Core Law**: Use OpenAI Agents SDK to orchestrate multi-turn reasoning, tool invocation, and response generation.

### Agent Setup
- **SDK**: `openai-agents` Python library
- **Model**: Latest OpenAI model (GPT-4-turbo, GPT-4o recommended)
- **System Prompt**: Define agent behavior (helpful task assistant, step-by-step guide)
- **Configuration**: API key in `.env`, never hardcoded

### Message Array Construction
- **History Fetch**: On each chat request, query `messages` table for conversation_id
- **Chronological Order**: Order by `created_at ASC` to reconstruct context
- **Format**: Convert to OpenAI message format: `{"role": "user|assistant", "content": "..."}`
- **Context Window**: Limit history to recent N messages (e.g., last 20) to avoid exceeding token limits

### Agent Execution Loop
1. Build message array from database
2. Append new user message
3. Call OpenAI Agents API with messages + tool definitions
4. Agent responds with:
   - **Text response** → Store in DB and return to user
   - **Tool call** → Execute tool, append result, loop again
5. Continue until agent outputs final response (no more tool calls)
6. Store final assistant message in database

### Tool Integration
- **Tool Binding**: Register 5 MCP tools with Agents SDK
- **Tool Execution**: When agent requests tool call, validate parameters and invoke MCP tool
- **Result Feedback**: Tool result appended to message array; agent continues reasoning
- **Error Handling**: Tool errors (validation, not found) returned as friendly messages

### Conversation Context
- **System Instruction**: "You are a helpful task management assistant..."
- **Constraints**: "Never create a task without asking for confirmation first"
- **Capabilities**: "You can add, update, complete, or delete tasks using tools"
- **Tone**: "Be concise, friendly, and always confirm actions"

### Rationale
Agents SDK handles complex multi-turn reasoning while developers focus on tool integration and UX. OpenAI's reasoning ensures natural conversation flow and contextual understanding.

---

## P3.10: Forbidden Phase-III Actions

**Core Law**: The following are strictly forbidden in Phase-III implementation.

### Absolute Prohibitions
- ❌ **Modifying Phase-II APIs**: No changes to `/api/users/{user_id}/tasks` or authentication endpoints
- ❌ **Direct Database Access by AI**: AI MUST NOT execute SQL queries; only via MCP tools
- ❌ **In-Memory Chat State**: No Flask sessions, no Redis cache of conversations, no server-side message queue
- ❌ **Auto Task Creation**: Never create tasks without explicit user confirmation
- ❌ **Parallel Backend**: No separate chatbot service; reuse Phase-II FastAPI server
- ❌ **Duplicate Task Logic**: No re-implementation of CRUD; only call Phase-II endpoints
- ❌ **Hardcoded Secrets**: API keys, JWT secrets MUST be in `.env` or environment variables
- ❌ **Cross-User Data Leakage**: No queries without `WHERE user_id = :user_id` filter

### Violation Consequences
- Code review blocks PR if violation detected
- Architecture review rejects design that violates this section
- Pre-commit hooks flag direct database imports in agent code

### Rationale
These prohibitions protect Phase-II integrity, enforce security, and prevent technical debt. Violations compromise the foundational design.

---

## P3.11: Phase-III Success Metrics

**Core Law**: Phase-III is successful when these observable outcomes are achieved.

### Functional Metrics
- ✅ **Chat-Created Tasks Appear in UI**: Task created via chatbot immediately visible in Phase-II task list (same `/api/users/{user_id}/tasks` endpoint)
- ✅ **UI-Created Tasks Visible to Chatbot**: Tasks created in Phase-II UI (manual CRUD) visible in chatbot's list_tasks tool
- ✅ **Conversation Persistence**: Close chat, refresh page, reopen → full message history restored
- ✅ **Server Restart Resilience**: Restart backend → conversation history remains; user can continue
- ✅ **User Isolation**: User A cannot access user B's conversations (403 if attempted)

### Technical Metrics
- ✅ **Zero Phase-II Regression**: All Phase-II tests pass; no API changes
- ✅ **MCP Tools Functional**: All 5 tools (add, list, update, complete, delete) callable and working
- ✅ **JWT Validation**: Every chat request requires valid JWT; 401 for invalid tokens
- ✅ **Database Integrity**: No orphaned messages; cascade deletes work correctly
- ✅ **Agent Reasoning**: Agent can handle multi-turn conversations; tool chaining works
- ✅ **Error Handling**: Friendly error messages for task-not-found, validation failures, network errors

### UX Metrics
- ✅ **Confirmation Before Action**: Destructive actions (delete, major update) require explicit confirmation
- ✅ **Natural Conversation**: AI understands intent, asks clarifying questions, confirms ambiguities
- ✅ **Mobile Responsive**: Chat widget works on mobile; not intrusive to existing UI
- ✅ **Fast Response Time**: Chat responds within 2-3 seconds (including AI inference + tool execution)

### Code Quality Metrics
- ✅ **Test Coverage**: Minimum 70% coverage for new code (chatbot endpoints, agent integration)
- ✅ **No Linting Violations**: Ruff + ESLint pass with zero warnings
- ✅ **Type Safety**: All Python and TypeScript code strictly typed; mypy + tsc pass
- ✅ **Traceability**: All code has Task ID comments referencing spec sections

### Rationale
These metrics ensure Phase-III delivers value (working chatbot), maintains system stability (Phase-II unchanged), and meets engineering standards (testing, quality, docs).

---

## Governance & Compliance (Phase-III Addition)

### Amendment Procedure (Updated for Multi-Phase)
1. **Identify Need**: Phase-III change needed (new principle, clarification, removal)
2. **Propose**: Draft amendment with rationale
3. **Ratify**: Adopt with version bump (3.1.0, 3.0.1, etc.)
4. **Propagate**: Update Phase-III spec/plan/task templates
5. **Record**: Add to Sync Impact Report with date and phase reference

### Phase Versioning
- **Phase-II Constitution**: v2.0.0 (locked; backward compatibility enforced)
- **Phase-III Constitution**: v3.0.0+ (evolves independently)
- **Joint Compliance**: Phase-III must never violate Phase-II constraints

### Compliance Review (Phase-III Additions)
Before Phase-III release, verify:
1. **Phase-II Preservation**: All Phase-II code and APIs unchanged
2. **MCP Integration**: Tools registered, tested, user-isolated
3. **Database**: Conversations and messages tables created, indexed, migrations tested
4. **Security**: JWT validation working, no cross-user leaks, API keys in environment
5. **Agent Function**: Agents SDK integrated, multi-turn reasoning working, tool calls functional
6. **UI Integration**: ChatKit embedded, floating widget responsive, no route changes
7. **Testing**: 70% coverage, all tests passing, error paths tested
8. **Documentation**: Spec, plan, tasks complete; CLAUDE.md updated for chatbot feature

### Enforcement
- **Code Review**: Phase-III PRs checked against P3.1–P3.11 principles
- **Pre-commit Hooks**: Block commits with missing Task IDs or security violations
- **Architecture Review**: Major decisions (agent model, tool design) reviewed for alignment
- **Automated Testing**: CI/CD runs Phase-II tests alongside Phase-III tests

---

## Summary: Phase-II + Phase-III Constitution

This updated constitution establishes governance for **two integrated phases**:

### Phase-II (12 Principles - Unchanged)
Core full-stack application: Next.js frontend, FastAPI backend, Neon PostgreSQL, JWT authentication, task CRUD.

### Phase-III (10 Principles - New)
AI chatbot layer: OpenAI Agents SDK, MCP tools, floating UI widget, conversation persistence, stateless backend, integrated with Phase-II.

### Key Phase-III Tenets
1. **Full-Stack Integration Only**: Reuse Phase-II, no parallel systems
2. **OpenAI-Only AI**: GPT-4, Agents SDK, no alternatives
3. **MCP-First Tools**: Stateless, user-scoped, confirmation-gated
4. **Conversational Safety**: Step-by-step data collection, explicit confirmation
5. **Stateless Backend, Persistent Memory**: Database stores conversations, not server memory
6. **Secure User Context**: JWT for every request, no cross-user data
7. **Embedded UI**: Float widget, no new routes, existing Phase-II unchanged
8. **Database Extensions Only**: `conversations` and `messages` tables only
9. **Agents Integration**: Multi-turn reasoning, tool orchestration, OpenAI
10. **Forbidden Actions**: No Phase-II modifications, no direct DB access, no auto-execution
11. **Success Metrics**: Chat-to-UI sync, persistence, isolation, 70% coverage
12. **Phase Separation**: Phase-II protected; Phase-III governed independently

### Governance Hierarchy
**Constitution > Spec > Plan > Tasks > Code**
- Phase-II and Phase-III operate under same hierarchy
- Phase-III cannot modify Phase-II; only extend
- Semantic versioning tracks all amendments

---

**Constitution Complete**
**Phase-II Foundation**: Established 2026-02-01, v2.0.0
**Phase-III Addition**: Added 2026-02-07, v3.0.0
**Next Steps**: Use `/sp.specify` to create Phase-III spec for AI chatbot feature aligned with this constitution.
