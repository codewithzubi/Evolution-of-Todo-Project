# Evolution of Todo: Phase 2 Constitution

**Project**: Evolution of Todo (Full-Stack Web Application)
**Phase**: Phase 2 (Console → Web with Multi-User, Persistent Storage, Authentication)
**Version**: 2.0.0
**Ratified**: 2026-02-01
**Last Amended**: 2026-02-01

---

## Sync Impact Report

- **Version Change**: 1.0.0 → 2.0.0 (MAJOR: substantial expansion of principles, addition of Progressive Evolution architecture, API/DB conventions, workflow enforcement)
- **Modified Principles**: Monorepo & Folder Sovereignty (expanded with CLAUDE.md guidance), Spec-First Development (added traceability comments), Security-First Implementation (expanded with Better Auth details)
- **Added Sections**: 12 core principles (was 7), External Context Integration, Spec File Organization, Quality Standards Checklist
- **Removed Sections**: None
- **Templates Updated**: ✅ spec-template.md, ✅ plan-template.md, ✅ tasks-template.md (verified compatible with new principles)
- **Follow-up TODOs**: None; all principles concrete and enforceable

---

## 1. Spec-First Development (Non-Negotiable)

**Core Law**: All code MUST be generated by Claude Code following the strict Specify → Plan → Tasks → Implement workflow. Manual code commits are forbidden.

### Mandatory Rules

- **Zero Manual Coding**: No human-authored code. All implementation must be artifact-driven and generated by Claude Code tools.
- **Traceability in Every Line**: Every single line of generated code MUST include an inline comment referencing its Task ID and Spec section:
  - **Python Format**: `# [Task]: T-XXX, [From]: specs/[section]`
  - **TypeScript Format**: `// [Task]: T-XXX, [From]: specs/[section]`
  - **Example** (Python): `# [Task]: T-005, [From]: specs/authentication/spec.md#FR-001`
- **Workflow Sequence (Immutable)**: Specify → Plan → Tasks → Implement. No Task ID = No Code. Every task must have a corresponding specification section.
- **Single Source of Truth**: The spec document (`.md`) is the authoritative source. Code comments MUST reference it, not vice versa.

### Rationale

Spec-first development ensures full end-to-end traceability from business requirements to implementation. It prevents drift from specifications, enables atomic rollback of features by Task ID, and maintains a complete audit trail for the hackathon. Every line of code can be linked back to a requirement and tested independently.

---

## 2. Progressive Evolution Architecture

**Core Law**: Phase 2 is the second phase in a planned 5-phase evolution. Backward compatibility with Phase 1 must be maintained, and the architecture must accommodate future phases.

### Evolution Roadmap

1. **Phase 1**: Console application (completed, in production)
2. **Phase 2**: Web application with multi-user support, persistent storage, JWT authentication
3. **Phase 3**: AI Chatbot integration (planned)
4. **Phase 4**: Local Kubernetes orchestration (planned)
5. **Phase 5**: Cloud Kubernetes deployment (planned)

### Phase 2 Constraints

- **Backward Compatibility**: Existing console app data models and workflows must be compatible with web interface. Use migration strategies (if needed) to bridge Phase 1 → Phase 2.
- **Stateless Services**: Backend services must not depend on Phase 1 console state. All state is persisted in the database.
- **Modular Architecture**: Components must be designed for extraction to microservices (Phase 4+). Avoid monolithic coupling.
- **Database as Single Source of Truth**: Web app relies entirely on Neon PostgreSQL; no in-memory caches without invalidation strategy.

### Rationale

Progressive evolution ensures the application can scale from a console tool to a cloud-native system without rewrites. Maintaining compatibility reduces migration risk and enables smooth onboarding of Phase 2 features alongside Phase 1 users (if applicable).

---

## 3. Clean Architecture & Stateless Services

**Core Law**: Separate concerns explicitly across models, services, API, and infrastructure layers. Backend must be completely stateless.

### Architectural Layers

- **Models Layer** (`backend/src/models/`): Data entities (User, Task) with validation, no business logic.
- **Services Layer** (`backend/src/services/`): Business logic, query composition, state transitions. Depends only on models and database.
- **API Layer** (`backend/src/api/`): HTTP endpoints, authentication/authorization, request/response marshaling. Depends on services.
- **Infrastructure** (`helm/`, `backend/.env`): Database, authentication providers, deployment configuration. Configured, not hard-coded.

### Stateless Backend Guarantee

- **No Session State**: Backend MUST NOT store user sessions in memory. All state lives in Neon PostgreSQL.
- **No File System State**: Temp files, caches, or uploaded assets must be persisted to external storage (e.g., S3-compatible) or database, never local disk.
- **Horizontal Scalability**: Any instance must be able to handle any request independently. No instance affinity.
- **JWT as Identity Token**: User identity travels in the JWT; backend extracts it and scopes queries accordingly.

### Rationale

Stateless services enable horizontal scaling, simplify deployment to Kubernetes (Phase 4), and reduce operational complexity. Clear separation of concerns reduces bugs and enables independent testing of each layer.

---

## 4. Security-First Implementation

**Core Law**: JWT authentication with Better Auth, strict endpoint protection, user data isolation, and no plain-text secrets.

### Authentication & Authorization

- **JWT Handshake**: Better Auth (Frontend) and FastAPI (Backend) MUST share the `BETTER_AUTH_SECRET` environment variable.
  - Secret is injected at runtime via `.env` (dev) or platform environment (prod).
  - Secret is NEVER committed to version control.
  - Secret is NEVER logged or transmitted in plain text.
- **Stateless Verification**: Backend MUST verify JWT on every request:
  - Missing or malformed token → `401 Unauthorized`
  - Expired or invalid signature → `401 Unauthorized`
  - Valid token → extract `user_id` claim and scope all queries to that user.
- **Token Claims**: JWT MUST include:
  - `user_id`: UUID or primary key of authenticated user (required for data isolation)
  - `exp`: Expiration timestamp (required for token validity)
  - `iat`: Issued-at timestamp (required for token age validation)

### Data Isolation (CRITICAL)

- **User Scoping**: Every query (GET, POST, PUT, DELETE) MUST be scoped by the `user_id` extracted from JWT:
  - Request path `user_id` ≠ JWT `user_id` → `403 Forbidden` (Forbidden, not 404, to avoid leaking existence of other users' resources)
  - No cross-user data leakage; this is a hard constraint.
  - Example: `GET /api/users/{user_id}/tasks` MUST verify that `user_id` in path matches JWT `user_id`.
- **Query-Level Enforcement**: All database queries include a `WHERE user_id = :user_id` clause. No exceptions.

### Secret Management

- **No Plain-Text Secrets**: Passwords, API keys, and tokens MUST never be stored, logged, or transmitted in plain text.
  - Passwords: Use bcrypt (minimum) for hashing. Store hashed values only.
  - Tokens: Use JWT with HS256 (HMAC-SHA256) signed by `BETTER_AUTH_SECRET`.
  - API Keys: Encrypt in database or store in secure vault (e.g., AWS Secrets Manager).
- **Environment Isolation**: `.env` files are for local development only, never committed. Production uses platform-provided environment variables.

### Input Validation

- **Pydantic Models (Backend)**: All request bodies MUST be validated via Pydantic models. Invalid input → `400 Bad Request` with error details.
- **Strict TypeScript (Frontend)**: All API client types MUST use strict TypeScript (strict: true in tsconfig). No `any` types.

### Rationale

JWT-based stateless authentication enables horizontal scaling and simplifies deployment. User-scoped queries prevent authorization bypass and multi-tenancy data leaks. Cryptographic enforcement (bcrypt, HS256) ensures secrets are never exposed even if logs or database are compromised.

---

## 5. Test-Driven Development & Quality Gates

**Core Law**: Minimum 70% test coverage. Strict typing. All code must pass Ruff (Python) and ESLint (JavaScript/TypeScript) linting.

### Test Coverage Requirements

- **Minimum 70% Coverage**: Measured via `pytest --cov` (Python) and `vitest --coverage` (JavaScript/TypeScript).
  - Coverage includes unit, integration, and contract tests.
  - Pre-commit hooks block commits that fall below 70%.
- **Unit Tests**: Test individual functions/methods in isolation.
  - Database queries use fixtures with test database (e.g., test PostgreSQL instance).
  - Services are unit-tested with mocked dependencies.
- **Integration Tests**: Test end-to-end workflows (e.g., user creation → task creation → task completion).
  - Use real database instance for integration tests.
  - Test error paths and edge cases.
- **Contract Tests**: Test API endpoints (request/response schemas, status codes, error handling).
  - Backend contract tests verify API matches spec.
  - Frontend contract tests verify backend API is callable and returns expected shape.

### Strict Typing

- **Python Type Hints**: All functions MUST have type hints for parameters and return values.
  - Example: `def create_user(name: str, email: str) -> User:`
  - Use `mypy` for static type checking. Zero `Any` types without justification.
- **Strict TypeScript**: `tsconfig.json` MUST have `"strict": true`.
  - All variables, function parameters, and return types MUST be typed.
  - No `any` types. Use generics or union types instead.

### Linting & Code Quality

- **Ruff (Python)**: Zero tolerance for violations. Pre-commit hooks enforce.
  - Configuration: `pyproject.toml` [tool.ruff]
  - Check: `ruff check src/`
  - Format: `ruff format src/`
- **ESLint (JavaScript/TypeScript)**: Zero tolerance for violations. Pre-commit hooks enforce.
  - Configuration: `.eslintrc.json`
  - Check: `eslint src/`
  - Auto-fix where possible.

### Test Execution

- **Before Every Commit**: Run linting and tests locally.
- **Pre-commit Hooks**: Automatically run tests and linting; block commits that fail.
- **CI/CD Pipeline**: GitHub Actions (or similar) runs full test suite on every push to main/develop.

### Rationale

70% coverage ensures critical paths are tested and bugs are caught early. Strict typing reduces runtime errors and enables refactoring with confidence. Linting enforces consistency, readability, and catches common mistakes. Pre-commit hooks prevent bad code from entering the repository.

---

## 6. Monorepo Structure & Documentation Standards

**Core Law**: Strictly organized monorepo with `/frontend`, `/backend`, `/specs`, `/helm` folders. CLAUDE.md files guide Claude Code at each level.

### Directory Structure

```
/
├── .specify/                          # Spec-Kit Plus governance
│   ├── memory/
│   │   └── constitution.md            # This file (System Laws)
│   ├── templates/
│   │   ├── spec-template.md
│   │   ├── plan-template.md
│   │   ├── tasks-template.md
│   │   └── phr-template.prompt.md
│   └── scripts/
│       └── bash/
│           ├── create-spec.sh
│           ├── create-phr.sh
│           └── ...
├── CLAUDE.md                          # Root-level guidance for Claude Code
├── frontend/                          # Next.js 16+ Web App
│   ├── CLAUDE.md                      # Frontend-specific guidance
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   ├── services/                  # API client services
│   │   └── hooks/
│   ├── tests/
│   │   ├── unit/
│   │   ├── integration/
│   │   └── contract/
│   ├── package.json
│   ├── tsconfig.json                  # strict: true required
│   └── .eslintrc.json
├── backend/                           # FastAPI Python 3.13+ Service
│   ├── CLAUDE.md                      # Backend-specific guidance
│   ├── src/
│   │   ├── models/
│   │   ├── services/
│   │   ├── api/
│   │   └── main.py                    # FastAPI app entry
│   ├── tests/
│   │   ├── unit/
│   │   ├── integration/
│   │   └── contract/
│   ├── pyproject.toml
│   ├── .env.example                   # Never commit .env
│   └── requirements.txt
├── specs/                             # Feature specifications
│   ├── authentication/
│   │   ├── spec.md
│   │   ├── plan.md
│   │   └── tasks.md
│   ├── task-management/
│   │   ├── spec.md
│   │   ├── plan.md
│   │   └── tasks.md
│   └── ...
├── specs-history/                     # Version history of specs
│   ├── authentication/
│   │   ├── spec-v1.0.0.md
│   │   └── spec-v1.1.0.md
│   └── ...
├── helm/                              # Infrastructure & Deployment
│   ├── values.yaml
│   ├── templates/
│   │   ├── deployment.yaml
│   │   └── service.yaml
│   └── ...
└── history/
    └── prompts/                       # Prompt History Records
        ├── constitution/
        ├── authentication/
        ├── task-management/
        └── general/
```

### CLAUDE.md Files (Guardians of Local Context)

Each service must have a `CLAUDE.md` file that guides Claude Code:

- **Root CLAUDE.md**: Monorepo-wide rules (Spec-First, naming conventions, module structure).
- **Frontend CLAUDE.md**: Next.js-specific guidance (App Router patterns, component structure, styling with Tailwind, API client patterns).
- **Backend CLAUDE.md**: FastAPI-specific guidance (endpoint structure, Pydantic models, SQLModel ORM patterns, error handling).

### Spec File Organization

- **One Feature per Directory**: `/specs/<feature-name>/`
- **Three Core Files per Feature**:
  1. `spec.md`: Feature requirements, user stories, acceptance criteria
  2. `plan.md`: Architecture decisions, technical approach, data models
  3. `tasks.md`: Testable atomic units of work with Task IDs (T-XXX)
- **Version Control**: Every spec iteration is tracked in `/specs-history/<feature>/<filename>-v<X.Y.Z>.md`
- **Naming Conventions**:
  - Feature directories use kebab-case: `task-management`, `user-authentication`, `ai-chatbot`
  - Spec files are lowercase: `spec.md`, `plan.md`, `tasks.md`

### Documentation Standards

- **Markdown Format**: All specifications and planning documents use GitHub Flavored Markdown (GFM).
- **Headings Hierarchy**: H1 for title, H2 for major sections, H3 for subsections. No skipped levels.
- **Code Blocks**: Use triple backticks with language identifier (python, typescript, sql, etc.).
- **Tables**: Use GFM table syntax for data structures, endpoints, and comparisons.
- **Comments in Specs**: Use HTML comments `<!-- -->` for editorial notes, action items, or clarifications.

### Rationale

Strictly organized monorepo reduces confusion, enables parallel work on frontend/backend/specs, and simplifies deployment. CLAUDE.md files ensure Claude Code respects service-specific constraints and patterns. Spec versioning in `/specs-history/` maintains audit trail and enables rollback. Clear documentation standards ensure specs are understandable and enforceable.

---

## 7. Feature Requirements & Constraints

**Core Law**: Phase 2 must implement all Basic Level task CRUD and completion features with the specified technology stack.

### Feature Scope (Phase 2 MVP)

- **User Authentication**: Sign up, log in, log out with Better Auth + JWT
- **Task Management**: Create, Read, Update, Delete (CRUD) tasks
- **Task Completion**: Mark tasks as complete/incomplete
- **User Data Isolation**: Users only see and modify their own tasks
- **Persistent Storage**: All data persists in Neon PostgreSQL
- **Multi-User Support**: Multiple concurrent users, independently isolated

### Technology Stack (Immutable for Phase 2)

| Layer | Technology | Rationale |
|-------|-----------|-----------|
| Frontend Framework | Next.js 16+ (App Router) | Modern React with server components, built-in optimization |
| Frontend Language | Strict TypeScript | Type safety at the boundary |
| Frontend Styling | Tailwind CSS | Utility-first, rapid UI development |
| Frontend Testing | Vitest, React Testing Library | Fast unit tests, realistic component testing |
| Backend Framework | FastAPI (Python 3.13+) | Modern, fast, async-native, built-in OpenAPI |
| Backend Language | Python 3.13+ | Type hints required, strict linting |
| Backend Testing | pytest, pytest-cov | Industry standard, excellent coverage reporting |
| ORM | SQLModel | Combines Pydantic (validation) + SQLAlchemy (queries) |
| Database | Neon PostgreSQL | Managed, serverless, scales with demand |
| Authentication | Better Auth | JWT-native, multi-provider support, production-ready |
| JWT Algorithm | HS256 (HMAC-SHA256) | Symmetric signing with `BETTER_AUTH_SECRET` |
| Package Management | UV (Python), pnpm (JavaScript) | Fast, deterministic, modern lock files |
| Deployment Frontend | Vercel | Seamless Next.js integration, automatic deploys |
| Deployment Backend | Railway or Render | Python support, managed databases, webhooks |
| Linting | Ruff (Python), ESLint (JS/TS) | Fast, zero-config, strict enforcement |

### Endpoint Security

- **All API endpoints** under `/api` MUST require valid JWT in `Authorization: Bearer <token>` header.
- **Exception**: `POST /api/auth/signup` and `POST /api/auth/login` (authentication endpoints themselves) do not require JWT.
- **Invalid token response**: `401 Unauthorized` with message "Invalid or expired token".

### Data Isolation

- **Core Principle**: Users can ONLY read/write their own tasks.
- **Enforcement**: Every query includes `WHERE user_id = :current_user_id` derived from JWT.
- **Example Query** (backend):
  ```python
  # backend/src/services/task_service.py
  # [Task]: T-012, [From]: specs/task-management/spec.md#FR-002
  async def get_user_tasks(user_id: str, db: Session) -> List[Task]:
      return db.query(Task).filter(Task.user_id == user_id).all()
  ```

### Rationale

These constraints ensure Phase 2 delivers a secure, multi-user web application while maintaining compatibility with Phase 1 and laying groundwork for Phases 3-5 (AI, Kubernetes, cloud). The technology stack is chosen for maintainability, scalability, and hackathon feasibility.

---

## 8. API Conventions

**Core Law**: All endpoints live under `/api` prefix. RESTful design with JSON request/response format.

### Endpoint Structure

```
POST   /api/auth/signup            # Register new user
POST   /api/auth/login             # Authenticate and return JWT
POST   /api/auth/logout            # Invalidate session (if applicable)

GET    /api/users/{user_id}/tasks  # List user's tasks
POST   /api/users/{user_id}/tasks  # Create new task for user
GET    /api/users/{user_id}/tasks/{task_id}  # Get specific task
PUT    /api/users/{user_id}/tasks/{task_id}  # Update task
DELETE /api/users/{user_id}/tasks/{task_id}  # Delete task

PATCH  /api/users/{user_id}/tasks/{task_id}/complete  # Mark task complete
PATCH  /api/users/{user_id}/tasks/{task_id}/incomplete # Mark task incomplete
```

### Request Format

All request bodies are JSON:

```json
{
  "title": "Buy groceries",
  "description": "Milk, eggs, bread",
  "priority": "high"
}
```

### Response Format (Success)

All successful responses follow this structure:

```json
{
  "success": true,
  "data": { /* entity */ },
  "message": "Task created successfully"
}
```

### Response Format (Error)

All error responses follow this structure:

```json
{
  "success": false,
  "error": {
    "code": "ERROR_CODE",
    "message": "Human-readable error message",
    "details": {}
  },
  "status": 400
}
```

### Status Codes

| Code | Meaning | Example |
|------|---------|---------|
| 200 | OK | Task retrieved successfully |
| 201 | Created | New task created |
| 204 | No Content | Task deleted successfully |
| 400 | Bad Request | Invalid JSON, missing required field |
| 401 | Unauthorized | Missing or invalid JWT token |
| 403 | Forbidden | Attempting to access another user's task |
| 404 | Not Found | Task does not exist (only return after verifying user isolation) |
| 500 | Internal Server Error | Unexpected backend error |

### Error Codes (Backend)

Define custom error codes for different failure modes:

- `AUTH_INVALID_CREDENTIALS`: Login failed (wrong password)
- `AUTH_USER_EXISTS`: User already registered
- `AUTH_MISSING_TOKEN`: Authorization header missing
- `AUTH_INVALID_TOKEN`: JWT signature invalid or expired
- `TASK_NOT_FOUND`: Task does not exist
- `TASK_VALIDATION_FAILED`: Task validation failed (e.g., empty title)
- `USER_NOT_FOUND`: User does not exist
- `FORBIDDEN_USER_MISMATCH`: Attempting to access another user's resource

### Documentation Requirement

Each endpoint MUST be documented in `specs/<feature>/contracts/` directory with:
- Request schema (Pydantic model or JSON Schema)
- Response schema
- Status codes and error codes
- Example request/response
- Authentication requirement

### Rationale

Consistent API conventions reduce client-side errors, simplify frontend integration, and enable automatic API documentation (via FastAPI's OpenAPI support). Standard status codes and error codes make debugging easier. JSON request/response format is language-agnostic and widely supported.

---

## 9. Database Conventions

**Core Law**: SQLModel ORM with Neon PostgreSQL. Strict foreign keys, required indexes, user-scoped queries.

### Schema Design

```python
# backend/src/models/user.py
# [Task]: T-003, [From]: specs/authentication/spec.md#FR-001
from sqlmodel import SQLModel, Field
from typing import Optional
import uuid

class User(SQLModel, table=True):
    """User account entity."""
    __tablename__ = "users"

    id: str = Field(default_factory=lambda: str(uuid.uuid4()), primary_key=True)
    email: str = Field(unique=True, index=True)
    password_hash: str  # bcrypt hash, NEVER plain text
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)


# backend/src/models/task.py
# [Task]: T-004, [From]: specs/task-management/spec.md#FR-002
from sqlmodel import SQLModel, Field
from datetime import datetime
from typing import Optional

class Task(SQLModel, table=True):
    """Task entity, always scoped to a user."""
    __tablename__ = "tasks"

    id: str = Field(default_factory=lambda: str(uuid.uuid4()), primary_key=True)
    user_id: str = Field(foreign_key="users.id", ondelete="CASCADE", index=True)
    title: str = Field(min_length=1, max_length=255)
    description: Optional[str] = None
    completed: bool = Field(default=False, index=True)
    priority: str = Field(default="normal")  # "low", "normal", "high"
    created_at: datetime = Field(default_factory=datetime.utcnow)
    updated_at: datetime = Field(default_factory=datetime.utcnow)
```

### Indexes

**Required Indexes**:
- `tasks.user_id`: Fast filtering by user (every query includes this)
- `tasks.completed`: Fast filtering of incomplete tasks (common query)
- `users.email`: Fast lookup by email (authentication)

Indexes are defined in the SQLModel class via `Field(index=True)`.

### Relationships

- **Foreign Keys**: `Task.user_id` → `User.id` with `OnDelete="CASCADE"` (delete user deletes all their tasks)
- **No Orphans**: Enforced at database level via foreign key constraints
- **Query Scoping**: All task queries include `WHERE user_id = :user_id` clause

### Migrations

- Use Alembic (SQLAlchemy migration tool) for schema changes
- Migration files in `backend/alembic/versions/`
- Every migration is versioned and can be rolled back
- Never modify existing migrations; create new ones for changes

### Data Types

| Concept | Type | Notes |
|---------|------|-------|
| User ID | UUID (string) | Use `uuid.uuid4()` for generation |
| Email | VARCHAR(255) | Unique index, case-insensitive queries |
| Password | VARCHAR(255) | Store bcrypt hash, minimum 60 characters for bcrypt |
| Title | VARCHAR(255) | Non-null, min 1 char, max 255 chars |
| Timestamps | DATETIME | UTC, auto-set on create/update |
| Boolean | BOOLEAN | For `completed`, `is_active`, etc. |

### Rationale

SQLModel combines Pydantic validation (frontend-like type safety) with SQLAlchemy ORM (powerful queries). Neon PostgreSQL provides managed, serverless scalability. Required indexes ensure fast queries at any user count. Foreign keys with CASCADE prevent orphaned data. UUID primary keys enable distributed generation without database round-trips.

---

## 10. Workflow Enforcement

**Core Law**: No code without a Task ID. No Task ID without a Spec section. Single source of truth is the specification.

### The Spec-First Workflow (Immutable Sequence)

1. **Specify**: Write user stories and requirements in `specs/<feature>/spec.md`
   - User stories describe **what** users can do
   - Requirements specify **constraints** and **rules**
   - Run `/sp.specify` to generate from natural language input
2. **Plan**: Design technical approach in `specs/<feature>/plan.md`
   - Architectural decisions (technology, patterns, data models)
   - Trade-offs and rationale
   - Data model sketches
   - Run `/sp.plan` to generate from spec
3. **Tasks**: Break down into atomic work items in `specs/<feature>/tasks.md`
   - Each task has a unique ID (T-001, T-002, etc.)
   - Each task references a Spec section and User Story
   - Tasks can be parallelized (marked with [P])
   - Run `/sp.tasks` to generate from plan
4. **Implement**: Generate code for each task
   - Task ID MUST be referenced in code comments
   - Code MUST reference the Spec section
   - Run `/sp.implement` to execute tasks (or use other Claude Code tools per task)

### Code Comment Traceability

Every line of code MUST link back to a task and spec:

**Python Example**:
```python
# [Task]: T-005, [From]: specs/authentication/spec.md#FR-001
async def create_user(email: str, password: str) -> User:
    password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt())
    user = User(email=email, password_hash=password_hash)
    # [Task]: T-005, [From]: specs/authentication/spec.md#FR-002
    db.add(user)
    db.commit()
    return user
```

**TypeScript Example**:
```typescript
// [Task]: T-010, [From]: specs/task-management/spec.md#FR-003
export async function createTask(userId: string, title: string): Promise<Task> {
  const response = await fetch(`/api/users/${userId}/tasks`, {
    method: 'POST',
    headers: { 'Authorization': `Bearer ${getToken()}` },
    // [Task]: T-010, [From]: specs/task-management/spec.md#FR-004
    body: JSON.stringify({ title })
  });
  return response.json();
}
```

### Violation Prevention

- **Pre-commit Hooks**: Block commits where code lacks Task ID comments (search for `\[Task\]` pattern)
- **Code Review**: Every PR must show which Tasks are being addressed
- **Task Tracking**: Use `/sp.tasks` to generate tasks before implementing

### Single Source of Truth

- **Source**: `/specs/<feature>/spec.md` is the authority on **what** to build
- **Design**: `/specs/<feature>/plan.md` documents **how** to build it
- **Work**: `/specs/<feature>/tasks.md` lists **where** to build
- **Code**: Comments reference spec sections, never contradict spec

### Rationale

Traceability prevents drift from requirements, enables feature rollback by Task ID, and maintains a complete audit trail. Pre-commit hooks catch violations early. Single source of truth prevents conflicting guidance and reduces confusion.

---

## 11. External Context Integration

**Core Law**: Claude Code MUST use the **context7 MCP server** to fetch latest documentation for all framework dependencies.

### When to Use context7

- **Framework Documentation**: Next.js 16, FastAPI, SQLModel, Better Auth, Neon PostgreSQL
- **Library APIs**: Pydantic, bcrypt, pytest, Vitest, Tailwind CSS
- **Integration Patterns**: How to combine Better Auth with FastAPI, Next.js with Tailwind, etc.
- **Breaking Changes**: Check for version-specific breaking changes or migration guides
- **Best Practices**: Fetch current security recommendations, performance tuning, etc.

### How to Invoke context7

Use the `mcp__context7__query-docs` MCP tool via Claude Code:

```
Query: "How to verify JWT tokens in FastAPI with custom claims?"
Library ID: "/fastapi/docs" or "/better-auth/docs"
```

Claude Code will fetch the latest documentation and return relevant examples.

### Documenting External Context

Every code snippet or pattern fetched from external documentation MUST be documented:

```python
# [Task]: T-008, [From]: specs/authentication/spec.md#FR-005
# External Context: Verified against FastAPI docs (context7 fetch)
# Pattern: https://fastapi.tiangolo.com/tutorial/security/simple-oauth2/
from fastapi import Depends, HTTPException
from fastapi.security import HTTPBearer

async def verify_jwt(credentials: HTTPBearer = Depends(HTTPBearer())):
    token = credentials.credentials
    try:
        payload = jwt.decode(token, BETTER_AUTH_SECRET, algorithms=["HS256"])
        user_id = payload.get("user_id")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")
    return user_id
```

### Rationale

Context7 MCP provides real-time access to framework documentation, reducing hallucination risk and ensuring generated code aligns with framework authors' current best practices. Documenting external context sources makes generated code verifiable and maintainable.

---

## 12. Quality Standards & Deliverables Checklist

**Core Law**: Phase 2 must deliver frontend UI, backend API, spec files, and CLAUDE.md guidance.

### Frontend Deliverables

- [ ] **Components**: Reusable UI components (Button, Input, Card, etc.) in `frontend/src/components/`
- [ ] **Pages**: Full pages implementing task management and authentication flows in `frontend/src/pages/`
- [ ] **Services**: API client service layer in `frontend/src/services/api.ts` (handles JWT, error handling, retries)
- [ ] **Hooks**: Custom React hooks for auth state, task queries, etc. in `frontend/src/hooks/`
- [ ] **Tests**: Unit tests for components, integration tests for workflows in `frontend/tests/`
- [ ] **Styling**: Tailwind CSS configured, all components styled, responsive design
- [ ] **TypeScript Strict**: `tsconfig.json` with `"strict": true`, zero `any` types
- [ ] **Linting**: All code passes ESLint, no warnings
- [ ] **Coverage**: Minimum 70% test coverage, verified with `vitest --coverage`

### Backend Deliverables

- [ ] **Models**: User and Task entities in `backend/src/models/` with SQLModel
- [ ] **Services**: Business logic in `backend/src/services/` (no DB queries in endpoints)
- [ ] **API Endpoints**: RESTful endpoints in `backend/src/api/` with JWT verification
- [ ] **Database**: Neon PostgreSQL schema with migrations
- [ ] **Error Handling**: Consistent error responses, proper status codes, error codes
- [ ] **Tests**: Unit, integration, and contract tests in `backend/tests/`
- [ ] **Type Hints**: All functions typed, `mypy` passes without errors
- [ ] **Linting**: All code passes Ruff, no violations
- [ ] **Coverage**: Minimum 70% test coverage, verified with `pytest --cov`
- [ ] **Logging**: Structured logging for debugging, no secrets logged

### Specification Deliverables

- [ ] **Feature Spec**: `specs/authentication/spec.md` with user stories and requirements
- [ ] **Feature Spec**: `specs/task-management/spec.md` with user stories and requirements
- [ ] **Plan**: `specs/authentication/plan.md` with technical approach
- [ ] **Plan**: `specs/task-management/plan.md` with technical approach
- [ ] **Tasks**: `specs/authentication/tasks.md` with Task IDs, dependencies, checklist
- [ ] **Tasks**: `specs/task-management/tasks.md` with Task IDs, dependencies, checklist
- [ ] **Contracts**: `specs/*/contracts/` directory with API endpoint documentation

### Documentation Deliverables

- [ ] **Root CLAUDE.md**: Monorepo-wide rules and conventions
- [ ] **Frontend CLAUDE.md**: Next.js patterns, component structure, styling guidelines
- [ ] **Backend CLAUDE.md**: FastAPI patterns, model structure, API conventions
- [ ] **README.md**: Project overview, how to run, deployment instructions
- [ ] **Quickstart.md**: Step-by-step guide for new developers (frontend + backend setup)
- [ ] **ADR Directory**: `history/adr/` with Architecture Decision Records for major decisions

### Quality Gates (Pre-Release)

- [ ] All tests pass (`pytest` + `vitest`)
- [ ] Test coverage ≥ 70% (both backend and frontend)
- [ ] All code passes linting (`ruff` + `eslint`)
- [ ] All code has Task ID comments referencing spec sections
- [ ] No plain-text secrets in code or logs
- [ ] JWT verification working end-to-end (frontend → backend)
- [ ] User data isolation verified (cannot access other users' tasks)
- [ ] All endpoints documented with request/response schemas
- [ ] Database migrations tested and reversible
- [ ] Error handling tested for all error paths

### Rationale

Comprehensive deliverables ensure Phase 2 is production-ready, well-documented, and maintainable. Quality gates catch issues before release and ensure compliance with constitution principles.

---

## Governance & Compliance

### Amendment Procedure

1. **Identify Need**: A change to this constitution is needed (new principle, clarification, removal)
2. **Propose**: Draft the amendment with rationale
3. **Ratify**: Adopt the amendment with a new version number (semantic versioning)
4. **Propagate**: Update dependent artifacts (spec/plan/task templates, CLAUDE.md files, etc.)
5. **Record**: Add amendment to Sync Impact Report with date and version bump

### Versioning Policy

- **MAJOR** (X.0.0): Backward-incompatible changes (principle removal, redefinition)
- **MINOR** (1.Y.0): New principles or sections added, expanded guidance
- **PATCH** (1.0.Z): Clarifications, wording, non-semantic refinements

### Compliance Review

Before any release, verify:

1. **Traceability**: All code has Task ID comments referencing spec sections
2. **Testing**: Test coverage ≥ 70%, all tests passing
3. **Linting**: Zero linting violations (Ruff, ESLint, mypy)
4. **Security**: No plain-text secrets, JWT verification working, user isolation enforced
5. **Documentation**: All endpoints documented, specs complete, CLAUDE.md guides present
6. **Specs**: All code has corresponding Task in `tasks.md`

### Enforcement

- **Pre-commit Hooks**: Block commits with missing Task IDs, linting violations, or test failures
- **Code Review**: Every PR verified against compliance checklist
- **Automated Testing**: CI/CD pipeline runs full test suite and linting on every push
- **Architecture Review**: ADRs created for major decisions; reviewed for alignment with constitution

---

## Appendix: Spec File Organization (Phase 2)

### Feature: Authentication

**Location**: `/specs/authentication/`

**Files**:
- `spec.md`: User registration, login, session management
- `plan.md`: JWT architecture, Better Auth integration, token lifecycle
- `tasks.md`: Backend JWT middleware, frontend auth hooks, integration tests

### Feature: Task Management

**Location**: `/specs/task-management/`

**Files**:
- `spec.md`: Task CRUD, completion status, user isolation
- `plan.md`: SQLModel schema, service layer design, error handling
- `tasks.md`: Models, CRUD endpoints, frontend UI, tests

### Feature: (Future) AI Chatbot

**Location**: `/specs/ai-chatbot/` (Phase 3)

**Files**: (To be created in Phase 3)

---

## Summary

This constitution establishes 12 non-negotiable principles for Evolution of Todo Phase 2:

1. **Spec-First Development**: No manual code; all generated via Specify → Plan → Tasks → Implement
2. **Progressive Evolution**: Phase 2 of 5-phase evolution; backward compatible
3. **Clean Architecture**: Separated layers; stateless backend; single source of truth
4. **Security-First**: JWT + Better Auth, user-scoped queries, no plain-text secrets
5. **Test-Driven**: 70% coverage, strict typing, zero linting violations
6. **Monorepo Structure**: Frontend, backend, specs, helm with CLAUDE.md guardians
7. **Feature Requirements**: Task CRUD, multi-user, JWT auth, Neon PostgreSQL
8. **API Conventions**: RESTful `/api` endpoints, JSON request/response, standard status codes
9. **Database Conventions**: SQLModel, required indexes, user-scoped queries
10. **Workflow Enforcement**: Task ID traceability, spec-first workflow, single source of truth
11. **External Context**: context7 MCP for framework documentation
12. **Quality Standards**: Comprehensive deliverables checklist, pre-release quality gates

All governance is hierarchical: **Constitution > Spec > Plan > Tasks > Code**. Amendments are tracked with semantic versioning. Compliance is enforced via pre-commit hooks, code review, and CI/CD automation.

**Next Steps**: Use `/sp.specify` to create feature specs for authentication and task management aligned with this constitution.

---

**Ratified by**: Claude Code (Spec-Driven Development Agent)
**Ratification Date**: 2026-02-01
**Next Review Date**: Upon completion of Phase 2 MVP (all deliverables checklist items ✅)
